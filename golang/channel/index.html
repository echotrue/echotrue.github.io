<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Golang channel</title>
<meta charset=utf-8><meta name=description content="Ladder@概念 从字面上看，channel的意思大概就是管道的意思。channel是一种goroutine用以接收或发送消息的安全的消息队列，chann"><meta name=author content="Axlrose"><link rel=canonical href=https://echotrue.github.io/golang/channel/><link rel=alternate type=application/rss+xml href=https://echotrue.github.io/index.xml title=AXLROSE><meta property="og:title" content="Golang channel"><meta property="og:description" content="概念 从字面上看，channel的意思大概就是管道的意思。channel是一种goroutine用以接收或发送消息的安全的消息队列，chann"><meta property="og:type" content="article"><meta property="og:url" content="https://echotrue.github.io/golang/channel/"><meta property="article:section" content="golang"><meta property="article:published_time" content="2020-09-08T14:51:55+08:00"><meta property="article:modified_time" content="2020-09-08T14:51:55+08:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Golangs","item":"https://echotrue.github.io/golang/"},{"@type":"ListItem","position":3,"name":"Golang channel","item":"https://echotrue.github.io/golang/channel/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang channel","name":"Golang channel","description":"概念 从字面上看，channel的意思大概就是管道的意思。channel是一种goroutine用以接收或发送消息的安全的消息队列，chann","keywords":["Go","channel"],"articleBody":"概念 从字面上看，channel的意思大概就是管道的意思。channel是一种goroutine用以接收或发送消息的安全的消息队列，channel就像两个goroutine之间的导管，来实现各种资源的同步。在官方Effective go文档中有一句非常著名的话可以说明channel在使用Golang进行并发编程的时候扮演了极为重要的角色\nDo not communicate by sharing memory; instead, share memory by communicating.\nChannel类型 readOnlyCh := make(\u003c-chan int)//表示一个元素类型为T的单向接收通道类型。 编译器不允许向此类型的值中发送数据。 writeOnlyCh := make(chan\u003c- int)//表示一个元素类型为T的单向发送通道类型。 编译器不允许从此类型的值中接收数据 readWriteCh := make(chan int)//表示一个元素类型为T的双向通道类型。 编译器允许从此类型的值中接收和向此类型的值中发送数据 阻塞 根据Channel缓冲区的大小，我们又可以将Channel分为Unbuffered channels与Buffered channels。其中，Unbuffered channels的缓冲区大小为0，这种channel的接收者会阻塞直至接收到消息，发送者会阻塞直至接收者接收到消息，这种机制可以用于两个goroutine进行状态同步。Buffered channels拥有缓冲区，当缓冲区已满时，发送者会阻塞；当缓冲区为空时，接收者会阻塞。引用The Nature Of Channels In Go中的两张图片来说明两种channel的特性。\nUnbuffered Channels Buffered Channels 基本用法 ch := make(chan string) go func() { ch \u003c- \"hello\" }() msg := \u003c-ch fmt.Println(msg) 以上代码，利用不带缓冲的channel双向阻塞的特性。主goroutine(就是main函数)会阻塞直到接收到子goroutine向ch中写入的值。所以保证了hello一定会输出。\n利用Channel实现并发的同步 基本用法中的代码片段使用阻塞接收的方式，实现了主goroutine等待子goroutine完成。最终达到了两个goroutine的同步。使用WaitGroup同样能达到多个goroutine的同步，尤其是需要等待多个协程的情况下，WaitGroup会是更好的选择。\nfunc worker(i int, wg *sync.WaitGroup) { defer wg.Done() time.Sleep(time.Second) fmt.Printf(\"worker %d stared\\n\", i) } func main() { var wg sync.WaitGroup for i := 1; i \u003c= 5; i++ { wg.Add(1) go worker(i, \u0026wg) } wg.Wait() } 执行结果：\nworker 1 stared worker 5 stared worker 4 stared worker 3 stared worker 2 stared Channel 选择器 select语句主要用在从多个读或者写channel的操作中进行选择。select语句会一直阻塞直到，有至少一个读或者写channel操作就绪。如果同时有多个操作准备就绪，select语句会随机选择其中一个执行。select语法类似switch，每个case相当于一个通道操作。\nc1 := make(chan string) c2 := make(chan string) go func() { time.Sleep(1 * time.Second) c1 \u003c- \"one\" }() go func() { time.Sleep(1 * time.Second) c2 \u003c- \"two\" }() for i := 0; i \u003c 2; i++ { select { case msg1 := \u003c-c1: fmt.Printf(\"接到消息：%s\\n\", msg1) case msg2 := \u003c-c2: fmt.Printf(\"接到消息：%s\\n\", msg2) } } 以上代码会输出：接到消息one，接到消息two。\nChannel遍历 for...range可以用来遍历通道，它会反复从通道接收数据直到通道关闭。\nqueue := make(chan string, 2) queue \u003c- \"one\" queue \u003c- \"two\" close(queue) for elem := range queue { fmt.Println(elem) } Channel 的关闭 内置函数close()可以用来关闭channel,close()函数只能关闭可读写或者只写的通道。通道的关闭通常应该遵循一定的原则：由生产者（发送者）来关闭，保证不关闭已关闭的通道(或向已关闭的通道发送值)。\nch := make(chan string) //可以关闭的通道 ch := make(chan\u003c- string) //可以关闭的通道 ch := make(\u003c-chan string) //不能关闭的通道 1、关闭 一个通道意味着不能再向这个通道发送值了。 该特性可以向通道的接收方传达工作已经完成的信息。\nmsg := make(chan string) done := make(chan bool) go func() { for { select { case m, ok := \u003c-msg: if ok { fmt.Printf(m) } else { fmt.Println(\"All message has received.\") done \u003c- true return } } } }() for i := 1; i \u003c 4; i++ { msg \u003c- fmt.Sprintf(\"Message %d\\n\", i) } close(msg) \u003c-done 2、向一个已经关闭的channel发送数据会panic\n3、从一个已经关闭的通道中读数据，依然可以读到数据。读到的内容是通道元素类型所对应的的零值。（例如：int类型channel读到的是0）。\nch := make(chan int) dataCh := make(chan string) go func() { dataCh \u003c- \"str one\" dataCh \u003c- \"str two\" close(dataCh) }() go func() { for { time.Sleep(time.Millisecond * 500) select { case str := \u003c-dataCh: fmt.Println(\"--\u003e\",str) } } }() \u003c-ch //输出： --\u003e str one --\u003e str two --\u003e --\u003e 4、当发送者关闭通道后，通道接收器可以通过向接收表达式分配第二个参数来判断通道是否关闭。c,ok := \u003c-ch，如果没有更多的值要接受且通道已经关闭，ok为false\nch := make(chan int) dataCh := make(chan string) go func() { dataCh \u003c- \"str one\" dataCh \u003c- \"str two\" close(dataCh) }() go func() { for { time.Sleep(time.Millisecond * 500) select { case str, ok := \u003c-dataCh: if ok { fmt.Println(\"--\u003e\", str) } else { fmt.Println(\"通道已关闭\") ch \u003c- 1 return } } } }() \u003c-ch channel的基本操作和注意事项 channel存在3种状态：\nnil，未初始化的状态，只进行了声明，或者手动赋值为nil active，正常的channel，可读或者可写 closed，已关闭，千万不要误认为关闭channel后，channel的值是nil channel可进行3种操作：\n读 写 关闭 把这3种操作和3种channel状态可以组合出9种情况：\n操作 nil的channel 正常channel 已关闭channel \u003c- ch 阻塞 成功或阻塞 读到零值 ch \u003c- 阻塞 成功或阻塞 panic close(ch) panic 成功 panic ","wordCount":"2046","inLanguage":"zh","datePublished":"2020-09-08T14:51:55+08:00","dateModified":"2020-09-08T14:51:55+08:00","author":{"@type":"Person","name":"Axlrose"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://echotrue.github.io/golang/channel/"},"publisher":{"@type":"Organization","name":"AXLROSE","logo":{"@type":"ImageObject","url":"https://echotrue.github.io/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.577e48febdf10d4dae6762f6211106404b18fa4dcfbb094391e62c58786eb335.css integrity="sha256-V35I/r3xDU2uZ2L2IREGQEsY+k3PuwlDkeYsWHhuszU=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/atom-one-dark.min.d51fd0897056947c1a907d5753da4b37e67f6c13b4ec4c836708e028a1b5687a.css><script src=/js/highlight.min.min.894ca9c68afab956438c4926a0dc7f5293e04e08595bd27abdb123e94801f684.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/game>Game</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/golang>Golang</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/art>生活</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>历史</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>标签</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Golang channel</h1></header><p><small>2020年9月8日&nbsp;· 2046 字&nbsp;· 5 分钟</small>
<small>·
<a href=https://echotrue.github.io/tags/go/>Go</a>
<a href=https://echotrue.github.io/tags/channel/>channel</a></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><ul><li><a href=#概念>概念</a></li><li><a href=#channel类型>Channel类型</a></li><li><a href=#阻塞>阻塞</a></li><li><a href=#a-idcode1基本用法a>基本用法</a></li><li><a href=#利用channel实现并发的同步>利用<code>Channel</code>实现并发的同步</a></li><li><a href=#channel-选择器>Channel 选择器</a></li><li><a href=#channel遍历>Channel遍历</a></li><li><a href=#channel-的关闭>Channel 的关闭</a></li><li><a href=#channel的基本操作和注意事项>channel的基本操作和注意事项</a></li></ul></li></ul></nav></div><section class=blog-content><h3 id=概念>概念</h3><p>  从字面上看，<code>channel</code>的意思大概就是管道的意思。<code>channel</code>是一种<code>goroutine</code>用以接收或发送消息的安全的消息队列，<code>channel</code>就像两个<code>goroutine</code>之间的导管，来实现各种资源的同步。在官方<code>Effective go</code>文档中有一句非常著名的话可以说明<code>channel</code>在使用<code>Golang</code>进行并发编程的时候扮演了极为重要的角色</p><blockquote><p><em>Do not communicate by sharing memory; instead, share memory by communicating.</em></p></blockquote><h3 id=channel类型>Channel类型</h3><pre tabindex=0><code>readOnlyCh  := make(&lt;-chan int)//表示一个元素类型为T的单向接收通道类型。 编译器不允许向此类型的值中发送数据。
writeOnlyCh := make(chan&lt;- int)//表示一个元素类型为T的单向发送通道类型。 编译器不允许从此类型的值中接收数据
readWriteCh := make(chan int)//表示一个元素类型为T的双向通道类型。 编译器允许从此类型的值中接收和向此类型的值中发送数据
</code></pre><h3 id=阻塞>阻塞</h3><p>  根据<code>Channel</code>缓冲区的大小，我们又可以将<code>Channel</code>分为<code>Unbuffered channels</code>与<code>Buffered channels</code>。其中，<code>Unbuffered channels</code>的缓冲区大小为0，这种<code>channel</code>的接收者会阻塞直至接收到消息，发送者会阻塞直至接收者接收到消息，这种机制可以用于两个<code>goroutine</code>进行状态同步。<code>Buffered channels</code>拥有缓冲区，当缓冲区已满时，发送者会阻塞；当缓冲区为空时，接收者会阻塞。引用<a href=https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html>The Nature Of Channels In Go</a>中的两张图片来说明两种<code>channel</code>的特性。</p><ul><li><code>Unbuffered Channels</code></li></ul><ul><li><code>Buffered Channels</code></li></ul><h3 id=a-idcode1基本用法a>基本用法</h3><pre tabindex=0><code>ch := make(chan string)

go func() {
    ch &lt;- &#34;hello&#34;
}()

msg := &lt;-ch
fmt.Println(msg)
</code></pre><p>  以上代码，利用不带缓冲的<code>channel</code>双向阻塞的特性。主<code>goroutine</code>(就是main函数)会阻塞直到接收到子<code>goroutine</code>向<code>ch</code>中写入的值。所以保证了<code>hello</code>一定会输出。</p><h3 id=利用channel实现并发的同步>利用<code>Channel</code>实现并发的同步</h3><p>  <a href=#code1>基本用法</a>中的代码片段使用阻塞接收的方式，实现了主<code>goroutine</code>等待子<code>goroutine</code>完成。最终达到了两个<code>goroutine</code>的同步。使用<code>WaitGroup</code>同样能达到多个<code>goroutine</code>的同步，尤其是需要等待多个协程的情况下，<code>WaitGroup</code>会是更好的选择。</p><pre tabindex=0><code>func worker(i int, wg *sync.WaitGroup) {
	defer wg.Done()
	time.Sleep(time.Second)
	fmt.Printf(&#34;worker %d stared\n&#34;, i)
}
func main() {
	var wg sync.WaitGroup
	for i := 1; i &lt;= 5; i++ {
		wg.Add(1)
		go worker(i, &amp;wg)
	}
	wg.Wait()
}
</code></pre><p>执行结果：</p><pre tabindex=0><code>worker 1 stared
worker 5 stared
worker 4 stared
worker 3 stared
worker 2 stared
</code></pre><h3 id=channel-选择器>Channel 选择器</h3><p>  <code>select</code>语句主要用在从多个读或者写<code>channel</code>的操作中进行选择。<code>select</code>语句会一直阻塞直到，有至少一个读或者写<code>channel</code>操作就绪。如果同时有多个操作准备就绪，<code>select</code>语句会随机选择其中一个执行。<code>select</code>语法类似<code>switch</code>，每个<code>case</code>相当于一个通道操作。</p><pre tabindex=0><code>c1 := make(chan string)
c2 := make(chan string)

go func() {
    time.Sleep(1 * time.Second)
    c1 &lt;- &#34;one&#34;
}()
go func() {
    time.Sleep(1 * time.Second)
    c2 &lt;- &#34;two&#34;
}()

for i := 0; i &lt; 2; i++ {
    select {
        case msg1 := &lt;-c1:
        fmt.Printf(&#34;接到消息：%s\n&#34;, msg1)
        case msg2 := &lt;-c2:
        fmt.Printf(&#34;接到消息：%s\n&#34;, msg2)
    }
}
</code></pre><p>以上代码会输出：接到消息one，接到消息two。</p><h3 id=channel遍历>Channel遍历</h3><p><code>for...range</code>可以用来遍历通道，它会反复从通道接收数据直到通道关闭。</p><pre tabindex=0><code>queue := make(chan string, 2)
queue &lt;- &#34;one&#34;
queue &lt;- &#34;two&#34;
close(queue)

for elem := range queue {
    fmt.Println(elem)
}
</code></pre><h3 id=channel-的关闭>Channel 的关闭</h3><p>  内置函数<code>close()</code>可以用来关闭<code>channel</code>,<code>close()</code>函数只能关闭可读写或者只写的通道。通道的关闭通常应该遵循一定的原则：由生产者（发送者）来关闭，保证不关闭已关闭的通道(或向已关闭的通道发送值)。</p><pre tabindex=0><code>ch := make(chan string) //可以关闭的通道
ch := make(chan&lt;- string) //可以关闭的通道
ch := make(&lt;-chan string) //不能关闭的通道
</code></pre><p>1、关闭 一个通道意味着不能再向这个通道发送值了。 该特性可以向通道的接收方传达工作已经完成的信息。</p><pre tabindex=0><code>msg := make(chan string)
done := make(chan bool)
go func() {
    for {
        select {
            case m, ok := &lt;-msg:
            if ok {
                fmt.Printf(m)
            } else {
                fmt.Println(&#34;All message has received.&#34;)
                done &lt;- true
                return
            }
        }
    }
}()

for i := 1; i &lt; 4; i++ {
    msg &lt;- fmt.Sprintf(&#34;Message %d\n&#34;, i)
}
close(msg)
&lt;-done
</code></pre><p>2、向一个已经关闭的<code>channel</code>发送数据会<code>panic</code></p><p>3、从一个已经关闭的通道中读数据，依然可以读到数据。读到的内容是通道元素类型所对应的的零值。（例如：int类型channel读到的是0）。</p><pre tabindex=0><code>ch := make(chan int)
dataCh := make(chan string)

go func() {
    dataCh &lt;- &#34;str one&#34;
    dataCh &lt;- &#34;str two&#34;

    close(dataCh)
}()

go func() {
    for {
        time.Sleep(time.Millisecond * 500)
        select {
            case str := &lt;-dataCh:
            fmt.Println(&#34;--&gt;&#34;,str)
        }
    }
}()

&lt;-ch

//输出：
--&gt; str one
--&gt; str two
--&gt; 
--&gt; 
</code></pre><p>4、当发送者关闭通道后，通道接收器可以通过向接收表达式分配第二个参数来判断通道是否关闭。<code>c,ok := &lt;-ch</code>，如果没有更多的值要接受且通道已经关闭，<code>ok</code>为<code>false</code></p><pre tabindex=0><code>ch := make(chan int)
dataCh := make(chan string)

go func() {
    dataCh &lt;- &#34;str one&#34;
    dataCh &lt;- &#34;str two&#34;

    close(dataCh)
}()

go func() {
    for {
        time.Sleep(time.Millisecond * 500)
        select {
            case str, ok := &lt;-dataCh:
            if ok {
                fmt.Println(&#34;--&gt;&#34;, str)
            } else {
                fmt.Println(&#34;通道已关闭&#34;)
                ch &lt;- 1
                return
            }
        }
    }
}()
&lt;-ch
</code></pre><h3 id=channel的基本操作和注意事项>channel的基本操作和注意事项</h3><p>channel存在<code>3种状态</code>：</p><ol><li>nil，未初始化的状态，只进行了声明，或者手动赋值为<code>nil</code></li><li>active，正常的channel，可读或者可写</li><li>closed，已关闭，<strong>千万不要误认为关闭channel后，channel的值是nil</strong></li></ol><p>channel可进行<code>3种操作</code>：</p><ol><li>读</li><li>写</li><li>关闭</li></ol><p>把这3种操作和3种channel状态可以组合出<code>9种情况</code>：</p><table><thead><tr><th style=text-align:left>操作</th><th style=text-align:left>nil的channel</th><th style=text-align:left>正常channel</th><th style=text-align:left>已关闭channel</th></tr></thead><tbody><tr><td style=text-align:left>&lt;- ch</td><td style=text-align:left>阻塞</td><td style=text-align:left>成功或阻塞</td><td style=text-align:left>读到零值</td></tr><tr><td style=text-align:left>ch &lt;-</td><td style=text-align:left>阻塞</td><td style=text-align:left>成功或阻塞</td><td style=text-align:left>panic</td></tr><tr><td style=text-align:left>close(ch)</td><td style=text-align:left>panic</td><td style=text-align:left>成功</td><td style=text-align:left>panic</td></tr></tbody></table></section><div class=paginator><a class=prev href=https://echotrue.github.io/golang/block-forever-in-go/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg><span>Block forever in Go</span></a>
<a class=next href=https://echotrue.github.io/golang/panic-and-recover/><span>Panic and Recover</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=related-resources></div></article></div><footer class=footer><p>&copy; 2023 <a href=https://echotrue.github.io>AXLROSE</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
Theme by
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>