<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title></title>
<meta charset=utf-8><meta name=description content="Ladder@tcp
三次握手
第一次握手
客户端将标志位SYN置1，随机产生一个值seq=J，并将数据包发给服务器Client进入SYN SENT状态，等待Server确认
万
第二次握手
服务器收到数据包后标志位SY=1知道客户端请求建立连接，服务器将标志位SYN和ACK都置1，随机产生一个值，并将数据包发给客户端确认连接请求，服务器进入SYNRCVD状态
第三次握手
客户端收到确认后若ACK为1，则将该数据包发送给服务器，服务器检查ACK为1则连接建立成功，客户端与服务器进入ESTABLISHED状态完成三次握手，可以传输数据"><meta name=author content="map[email:axlrose.huang@gmail.com name:Axlrose]"><link rel=canonical href=https://echotrue.github.io/blog/101/backend/><link rel=alternate type=application/rss+xml href=https://echotrue.github.io//index.xml title=AXLROSE><meta property="og:url" content="https://echotrue.github.io/blog/101/backend/"><meta property="og:site_name" content="AXLROSE"><meta property="og:title" content="AXLROSE"><meta property="og:description" content="tcp 三次握手 第一次握手 客户端将标志位SYN置1，随机产生一个值seq=J，并将数据包发给服务器Client进入SYN SENT状态，等待Server确认 万 第二次握手 服务器收到数据包后标志位SY=1知道客户端请求建立连接，服务器将标志位SYN和ACK都置1，随机产生一个值，并将数据包发给客户端确认连接请求，服务器进入SYNRCVD状态 第三次握手 客户端收到确认后若ACK为1，则将该数据包发送给服务器，服务器检查ACK为1则连接建立成功，客户端与服务器进入ESTABLISHED状态完成三次握手，可以传输数据"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-11-26T14:22:41+00:00"><meta property="article:modified_time" content="2024-11-26T14:22:41+00:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://echotrue.github.io/blog/"},{"@type":"ListItem","position":2,"name":"","item":"https://echotrue.github.io/blog/101/backend/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"tcp 三次握手 第一次握手 客户端将标志位SYN置1，随机产生一个值seq=J，并将数据包发给服务器Client进入SYN SENT状态，等待Server确认 万 第二次握手 服务器收到数据包后标志位SY=1知道客户端请求建立连接，服务器将标志位SYN和ACK都置1，随机产生一个值，并将数据包发给客户端确认连接请求，服务器进入SYNRCVD状态 第三次握手 客户端收到确认后若ACK为1，则将该数据包发送给服务器，服务器检查ACK为1则连接建立成功，客户端与服务器进入ESTABLISHED状态完成三次握手，可以传输数据\n","keywords":[],"articleBody":"tcp 三次握手 第一次握手 客户端将标志位SYN置1，随机产生一个值seq=J，并将数据包发给服务器Client进入SYN SENT状态，等待Server确认 万 第二次握手 服务器收到数据包后标志位SY=1知道客户端请求建立连接，服务器将标志位SYN和ACK都置1，随机产生一个值，并将数据包发给客户端确认连接请求，服务器进入SYNRCVD状态 第三次握手 客户端收到确认后若ACK为1，则将该数据包发送给服务器，服务器检查ACK为1则连接建立成功，客户端与服务器进入ESTABLISHED状态完成三次握手，可以传输数据\n问题1:为什么建立连接是三次握手，四次不可以吗 第一次握手: 客户(Client)什么都不能确认 服务器(Server)确认了对方发送正常 第二次握手: Client确认:自己发送/接收正常，对方发送/接收正常 服务器确认:自己接收正常，对方发送正常 第三次握手: Client确认:自己发送/接收正常，对方发送/接收正常 Server确认:自己发送/接收正常，对方发送/接收正常 所以通过三次握手确认双方收发功能都正常，四次也可以但是显得比较多余。\n四次挥手 第一次挥手：\nClien发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。\n第二次挥手：\nServer收到FIN后，发送一个ACK给Client,Server进入CLOSE_WAIT状态。\n第三次挥手：\nServer发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。\n第四次挥手：\nClient收到FIN后，Client进入TIME_WAIT状态，发送ACK给Server，Server进入CLOSED状态，完成四次握手。\n问题：为什么建立连接是三次握手，而关闭连接却是四次挥手呢？ 建立连接\n因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。\n关闭连接\n当收到对方的FIN报文时，仅表示对方不再发送数据但还能接收收据，我们也未必把全部数据都发给了对方，所以我们可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方表示同意关闭连接。因此我们的ACK和FIN一般会分开发送。\ntcp和udp的区别 TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种主要的传输层协议，各自适用于不同的应用场景。以下是两者的主要区别：\n1. 连接方式 TCP（面向连接）：\n在数据传输之前需要建立连接（三次握手）。 传输结束后需要释放连接（四次挥手）。 提供可靠的传输，适合需要数据完整性保证的场景。 UDP（无连接）：\n不需要建立和释放连接。 直接发送数据，无需握手。 是一种不可靠传输协议，适合对速度要求高且可以容忍丢包的场景。 2. 可靠性 TCP：\n提供可靠的数据传输。 包含错误校验、重传机制、流量控制和拥塞控制。 保证数据的顺序性，不会出现数据乱序。 UDP：\n不保证数据的可靠性。 没有重传机制，可能会丢包或乱序。 没有流量控制和拥塞控制，适合实时性要求高的应用。 3. 传输效率 TCP：\n由于需要建立连接、确认数据、处理重传和流量控制，开销较大，传输速度较慢。 UDP：\n传输过程简单，无需确认和重传，效率更高，适合实时性强的场景。 4. 数据格式 TCP：\n数据以流的形式传输，没有明确的消息边界。 适合连续的数据传输，如文件传输和长时间连接。 UDP：\n数据以数据报（Datagram）的形式发送，每个报文独立。 适合短小的数据传输，如请求-响应模型。 5. 应用场景 TCP：\n适用于对数据可靠性要求高的场景： HTTP/HTTPS（网页浏览） FTP（文件传输） SMTP（邮件传输） UDP：\n适用于对实时性要求高的场景： DNS查询 视频会议（如Zoom） 在线游戏 流媒体传输 总结对比表 特性 TCP UDP 是否连接 面向连接 无连接 可靠性 可靠 不可靠 传输效率 较低 较高 数据顺序 保证顺序 不保证顺序 流量控制与拥塞控制 有 无 数据传输方式 流式传输 报文传输 典型应用场景 文件传输、网页、邮件 视频、语音、游戏、DNS 根据需求选择适合的协议可以更好地优化系统性能和用户体验。\ngolang 接口 接口的作用\n抽象和解耦\n接口用于定义行为，而不是实现。通过接口可以实现代码的模块化和解耦，使程序更加灵活和可扩展。\n多态\nGo语言通过接口实现了多态，一个接口可以被多个不同类型实现，这使得代码更加通用。\n统一方法调用\n定义接口后，调用代码不需要知道具体类型，只需要依赖接口类型。\n2. 接口的用处 设计灵活的代码结构\n通过接口定义不同模块的交互方式，而无需了解其内部实现。 提高代码的可测试性，因为可以用接口模拟不同的实现进行测试。 实现依赖倒置\n高层模块依赖接口，而不是具体实现，符合面向接口编程的原则。\n便于扩展\n新增实现类型时无需更改现有代码，只需要实现接口即可。\n标准化行为\n定义一组方法契约，不同类型只要实现这些方法，就可以统一处理。\n总结 接口是Go语言的重要特性，用于实现抽象、解耦和多态。通过定义行为接口，程序可以实现灵活的模块化设计，同时增强代码的可扩展性和测试性。合理地设计和使用接口是编写优雅Go代码的关键。\ngolang 空结构体 在 Golang 中，空结构体（struct{}）是一种特别轻量级的类型，具有一些独特的性质和用途。以下是关于空结构体的详细解答：\n用途： 节省内存的占位符，用于集合、标记等。 通信信号传递。 用于轻量级对象实现。 内存： 空结构体本身不占用内存，但作为切片或数组元素时会有附加开销。 可比较性： 空结构体是可比较的，并且所有空结构体值总是相等。 使用空结构体可以在合适的场景下有效减少内存开销，是 Go 语言中一个非常实用的设计模式。\ngo默认参数和可选参数 golang不直接支持默认参数或可选参数，可以间接通过边长参数或者结构体封装参数实现类似的功能\nGolang 的协程（goroutines）和传统线程（threads）虽然都用于并发编程，但在设计理念、实现方式和性能表现上有显著差异。以下是对它们的详细比较：\n1. 概念与设计理念 属性 Goroutines Threads 本质 用户态轻量级线程，由 Go 运行时调度。 内核态线程，由操作系统调度。 调度 Go 运行时使用 M:N 调度（多个 goroutine 映射到多个 OS 线程）。 由操作系统内核调度，通常是 1:1 的线程模型。 启动开销 极低，创建一个 goroutine 的开销约 2KB。 较高，创建线程需要分配栈内存（通常 1MB）。 栈大小 动态调整，初始为 2KB，可增长到 GB 级别。 固定大小，通常为 1MB，可能导致内存浪费。 2. 性能对比 属性 Goroutines Threads 创建速度 更快，数百万 goroutines 可并发运行。 较慢，系统对线程数有限制（通常是数千个）。 切换成本 低，Go 运行时管理切换，避免了用户态与内核态切换的开销。 高，线程切换涉及内核态与用户态的上下文切换。 资源利用 更高效，轻量级，适合高并发场景。 较重，线程需要更多的内存和 CPU 资源。 3. 通信方式 属性 Goroutines Threads 通信机制 推荐通过 通道（channel） 进行通信，鼓励“不要通过共享内存通信，而是通过通信共享内存”。 通常通过 共享内存（如锁、条件变量）进行通信。 数据安全性 Channel 提供内置的同步机制，数据交换更安全。 必须手动使用锁（如互斥锁、读写锁）保护共享数据。 开发复杂度 更低，goroutines + channels 使并发代码更直观。 更高，需要手动管理线程安全。 4. 可扩展性 属性 Goroutines Threads 并发数量 支持数百万级的 goroutines。 通常支持数千级的线程，受限于内存和操作系统开销。 扩展性 运行时自带调度器（GMP 模型），动态调整线程数以适应系统负载。 受限于操作系统调度能力，多线程编程复杂且效率较低。 5. 易用性与编程体验 属性 Goroutines Threads 易用性 语法简单（go func()），开发者无需管理栈和调度细节。 较复杂，需要管理线程创建、销毁、同步等操作。 代码简洁性 Goroutines + channels 提供更高层次的抽象。 手动处理锁、条件变量，代码容易变得复杂且难以维护。 错误恢复 recover 机制可以处理 goroutines 中的 panic。 线程崩溃通常会导致整个程序崩溃。 6. 使用场景 属性 Goroutines Threads 适用场景 高并发、轻量级任务（如 Web 服务、消息处理）。 CPU 密集型任务，或需要操作系统级特性的场景（如硬件交互）。 场景限制 不适合需要直接操作线程特性（如线程优先级、线程绑定）的场景。 多线程适合需要精细控制的底层编程。 7. 运行机制 Goroutines\nGo 的 GMP 模型：\nG: Goroutines，表示协程。 M: Machine，表示 OS 线程。 P: Processor，表示逻辑处理器，用于执行 goroutines。 Go 运行时动态将 Goroutines 分配到多个线程上执行，且会自动调度，避免了开发者直接操作线程的复杂性。 Threads\n由操作系统的线程调度器管理。 开销大，线程调度和切换成本较高。 8. 优劣势总结 属性 Goroutines Threads 优势 轻量、高效、简单易用、扩展性强 功能强大、控制细粒度高 劣势 不支持线程优先级、依赖 Go 运行时 创建和管理开销高，复杂度大 总结 选择 Goroutines 的场景： 高并发、高 I/O 的应用（如 Web 服务、微服务）。 对内存占用和切换开销敏感的应用。 希望代码更加简洁、易读、易维护。 选择 Threads 的场景： 操作系统级别的任务（如硬件交互、系统调用）。 需要特定线程特性（如优先级、绑定核心）。 多语言混合开发或现有项目需要兼容多线程模型。 总之，Goroutines 是 Go 语言的核心优势之一，适合大多数高并发场景，而 Threads 仍然在需要底层控制的应用中占有一席之地。\n在 Go 语言中，GMP 模型是其运行时（runtime）用来调度和管理并发的核心机制。GMP 是一种高效的 M:N 调度模型，其中多个 Goroutine 映射到多个操作系统线程运行，旨在最大化 CPU 的利用率并简化开发者管理并发的复杂性。\nGMP 模型的组成 GMP 由三个关键组件构成：\nG (Goroutine)\n表示 Go 语言中的协程，是由 Go 运行时管理的轻量级线程。 每个 Goroutine 包含栈、任务函数以及调度所需的状态信息。 Goroutine 的栈初始为 2KB，可动态增长和收缩（相比传统线程的固定栈大小更加节省内存）。 M (Machine)\n表示操作系统线程（OS Thread），负责执行 Goroutine。 每个 M 对应一个操作系统线程，但一个 M 可以执行多个 G。 M 由 Go 运行时管理，避免了操作系统线程的直接调度开销。 P (Processor)\n表示逻辑处理器，是 G 和 M 之间的桥梁。 P 决定了 Goroutine 能够并发运行的最大数量，P 的数量由 GOMAXPROCS 环境变量决定。 每个 P 持有一个 Goroutine 队列，M 从 P 的队列中获取 G 运行。 GMP 的工作原理 调度过程 创建 Goroutine (G)：\n当使用 go 关键字启动一个协程时，会创建一个新的 G，放入到某个 P 的队列中等待执行。 执行 Goroutine (G)：\n一个 M 从 P 的本地队列中取出 G 并执行。 如果本地队列为空，M 会从全局队列或其他 P 的队列中窃取 Goroutine。 阻塞与切换：\n如果一个 Goroutine 阻塞（如系统调用），其绑定的 M 会解除与 P 的绑定，释放 P 供其他 M 使用。 被阻塞的 M 会等待操作完成后返回全局线程池。 工作窃取：\n当一个 P 的本地队列为空时，运行时会尝试从其他 P 的队列中窃取任务（work stealing），确保资源利用率最大化。 运行时组件的交互 G 与 P：\nG 需要绑定一个 P 才能被调度运行。 P 是逻辑处理器，管理 Goroutine 的本地队列。 M 与 P：\nM 需要与 P 绑定后才能运行 G。 当 M 执行 G 时，P 提供调度上下文和任务队列。 全局队列：\n新创建的 Goroutine 可能会先进入全局队列，当 P 的本地队列有空位时再从全局队列拉取任务。 GMP 的特点 1. 动态线程管理 M（OS 线程）的数量不固定，Go 运行时根据负载情况动态增加或减少线程数。 阻塞的线程会释放 P，避免因阻塞操作而浪费处理器资源。 2. 动态栈管理 Goroutine 的栈初始为 2KB，可根据需要动态增长（最大可到 1GB）。 相比线程的固定栈（通常 1MB），大幅减少了内存占用。 3. 工作窃取 当一个 P 的任务队列为空时，会尝试从其他 P 的任务队列中窃取任务，从而平衡负载，提高 CPU 利用率。 4. 全局调度 Go 运行时维护一个全局任务队列，P 的本地队列不足时可以从全局队列中获取任务。 GOMAXPROCS 和并发控制 GOMAXPROCS 控制逻辑处理器（P）的数量，默认值为运行环境中的 CPU 核心数。 可以通过 runtime.GOMAXPROCS 或环境变量修改： runtime.GOMAXPROCS(4) // 设置逻辑处理器数量为 4 影响： 增大 GOMAXPROCS： 提高并发能力，但可能引入更多线程切换的开销。 减小 GOMAXPROCS： 限制并发 Goroutine 的数量，有助于降低竞争，但可能导致资源利用不足。 GMP 模型的优点 高效的调度：\nGMP 模型避免了直接使用线程带来的高开销，通过用户态调度实现轻量级并发。 优异的资源利用率：\n动态线程管理和工作窃取机制确保 Goroutine 能最大程度地利用系统资源。 简化并发编程：\n开发者无需直接管理线程，go 关键字和 channel 机制提供了简单直观的并发抽象。 GMP 调度的缺点 依赖 Go 运行时：\nGMP 的调度完全依赖 Go 运行时，在某些高性能场景下不如手动优化的线程池。 非实时性：\nGoroutine 的调度是软实时的，无法保证实时任务的绝对响应时间。 复杂性：\n虽然对开发者透明，但 GMP 模型的内部调度逻辑相对复杂，可能在极端情况下引发性能问题。 总结 GMP 模型是 Go 语言并发编程的核心，具有以下关键特性：\n轻量级并发：Goroutines 运行时轻量，启动和切换开销低。 自动调度：通过 P 控制并发数量，M:N 调度避免了操作系统线程的高开销。 高效的负载均衡：通过工作窃取机制优化资源分配。 通过 GMP，Go 实现了高效的并发处理，特别适合 I/O 密集型和高并发场景，如 Web 服务、分布式系统等。\n在实际应用中，Redis 和 MySQL 通常被组合使用：\nMySQL 作为主存储，提供可靠的持久化存储能力。 Redis 作为缓存，提供高性能的读取服务。 为了保证两者数据的一致性，常见的同步方案包括主动同步、被动同步和混合模式。以下是详细的实现方式：\n主动同步 主动同步由业务逻辑控制，典型步骤是：\n更新数据库： 数据被写入 MySQL。 同步缓存： 数据同时或随后同步到 Redis。 被动同步** 在被动同步模式中，Redis 不主动同步数据，而是根据需要从 MySQL 中加载数据。\n这是典型的 缓存失效策略，即“从缓存中取不到数据时才查询数据库”。\n混合模式** 在高并发场景下，可以结合主动同步和被动同步，既保证性能又提升一致性。\n例如：\n热点数据： 使用主动同步，更新时同步到 Redis。 冷门数据： 使用被动同步，按需加载到 Redis。 3. 数据一致性问题 问题来源 缓存与数据库异步更新： MySQL 更新后，Redis 缓存可能未及时更新。 缓存穿透、雪崩和击穿： 穿透： 查询一个不存在的数据，会导致频繁访问 MySQL。 雪崩： 缓存大规模失效时，所有请求直接访问 MySQL。 击穿： 某些热点数据突然失效，大量请求同时访问数据库。 解决方法 3.1 缓存更新策略 写后删除：\n更新 MySQL 数据后，删除 Redis 中的旧数据。 func updateData(key, value string) error { // 1. 更新 MySQL 数据 if err := updateMySQL(key, value); err != nil { return err } // 2. 删除 Redis 缓存 if err := deleteRedis(key); err != nil { log.Printf(\"Failed to delete Redis key: %v\", err) } return nil } 写后更新：\n更新 MySQL 后，立即将新数据写入 Redis。 3.2 防止缓存穿透 设置空值缓存： 对不存在的数据写入空值到 Redis，避免频繁访问数据库。 布隆过滤器： 使用布隆过滤器拦截无效查询。 3.3 防止缓存雪崩 缓存预热： 在系统启动时提前将热点数据加载到缓存。 随机过期时间： 缓存的过期时间加上随机值，避免大规模同时失效。 3.4 防止缓存击穿 热点数据加锁： 缓存失效时，使用分布式锁限制同时查询 MySQL。 永久缓存： 对特别热点的数据设置为永久缓存，同时异步更新。 5. 总结 Redis 与 MySQL 数据同步有多种方式，需要根据场景选择合适的策略：\n需求 推荐策略 高一致性要求 主动同步 + 写后删除或写后更新。 高性能、低延迟 被动同步 + 缓存失效重建。 高并发、热点数据 混合模式，热点数据主动同步，冷门数据被动同步。 数据变更实时性高 借助 Canal 或消息队列实现实时同步。 每种方案都有优缺点，实际应用中需要根据业务特点、性能要求和一致性需求进行权衡和选择。\nMySQL 索引建立的基本原则 基于查询需求建立索引\n索引的核心目的是优化查询，尤其是频繁使用的查询语句（如 SELECT）。 分析查询模式，优先为 WHERE 条件、JOIN 条件、GROUP BY 和 ORDER BY 列建立索引。 选择性高的列优先建立索引\n列的选择性（区分度）是指不重复值的比例，公式为： 选择性=列中不重复值的数量总行数\\text{选择性} = \\frac{\\text{列中不重复值的数量}}{\\text{总行数}}选择性=总行数列中不重复值的数量​ 选择性高的列（如唯一标识符）更适合作为索引，因为它能快速缩小查询范围。\n对于选择性低的列（如性别、布尔值），索引效果不佳。 复合索引优于单列索引\n对涉及多列的查询（如多条件查询）使用复合索引可以避免多个单列索引的性能不足。 复合索引遵循 最左前缀匹配原则： 如果有 (a, b, c) 的复合索引，可以支持查询 a，a AND b，a AND b AND c。 但查询中未使用索引的最左列时（如 b AND c），索引失效。 避免过多或冗余的索引\n每个索引都会增加写操作的成本（插入、更新、删除时需要维护索引）。 冗余索引（功能重复的索引）会浪费存储资源，应尽量减少。 覆盖索引\n覆盖索引是指查询所需的数据完全存储在索引中，不需要回表查询。\n覆盖索引通常能显著提高查询性能，特别是在只读场景中。\nsql\n复制代码\nCREATE INDEX idx_user_name ON users (name, email); SELECT name, email FROM users WHERE name = 'John';\n避免对频繁更新的列建立索引\n索引需要随列值更新而更新，因此频繁变化的列（如时间戳、状态）会增加维护开销。 避免对低基数列建立索引\n低基数列（如布尔值、性别）索引无法有效缩小查询范围，通常对性能提升有限。 如果查询中涉及低基数列，建议结合高基数列或其他优化手段。 为外键列建立索引\n外键关联的列通常用于 JOIN 操作，建立索引可加速关联查询。 谨慎使用全文索引和前缀索引\n全文索引适用于大文本字段的搜索（如文章内容），但仅在特殊场景使用。\n前缀索引适用于长度较长的字符串列（如 URL、邮件地址），但可能导致查询精度降低。\nsql\n复制代码\nCREATE INDEX idx_email_prefix ON users (email(10));\n分区和分库分表情况下的索引\n在分区表中，建议在分区键上建立索引。 在分库分表场景下，需考虑全局唯一性需求，避免对跨库 JOIN 的列建立过多索引。 Redis 提供了两种主要的持久化方式，用于将内存中的数据保存到磁盘，防止数据丢失：\nRDB（Redis DataBase）快照持久化 AOF（Append Only File）日志持久化 此外，Redis 还支持 混合持久化，结合了 RDB 和 AOF 的优势。\n1. RDB 持久化 原理 RDB 持久化会定期将 Redis 中的数据快照保存到二进制文件（默认文件名为 dump.rdb）。 它是一次性保存 Redis 数据的完整副本。 触发机制 RDB 可以通过两种方式触发：\n自动触发（配置文件）\nRedis 配置文件中可以设置保存快照的条件：\nbash\n复制代码\nsave 900 1 # 900秒内（15分钟）至少有1次写操作 save 300 10 # 300秒内（5分钟）至少有10次写操作 save 60 10000 # 60秒内至少有10000次写操作\n满足条件时，Redis 自动执行 RDB 快照。\n手动触发\n使用 SAVE 命令：阻塞 Redis 服务并立即生成 RDB 文件。 使用 BGSAVE 命令：以非阻塞方式在后台生成 RDB 文件。 优点 RDB 文件体积小，适合备份和快速迁移。 恢复数据速度快（加载一个完整的快照）。 对 Redis 性能的影响较小，因其是周期性操作。 缺点 数据丢失风险较高：快照是定期生成的，若 Redis 崩溃，可能丢失最后一次快照之后的数据。 快照生成过程可能较慢，占用大量的 CPU 和内存。 2. AOF 持久化 原理 AOF 持久化记录每个写操作的命令日志（以 Redis 协议保存），并追加到文件（默认文件名为 appendonly.aof）。 当 Redis 重启时，通过重放这些命令重建数据。 触发机制 日志写入时机\n根据配置，Redis 会将写命令同步到 AOF 文件，主要有以下模式：\nbash\n复制代码\nappendfsync always # 每次写操作都立即同步到磁盘，性能低但最安全 appendfsync everysec # 每秒同步一次，性能与安全性平衡 appendfsync no # 由操作系统决定何时同步，性能最高但风险最大\n文件重写（Rewrite）\n随着 AOF 文件的不断增长，文件可能会变得非常大。Redis 提供了 AOF 重写机制： 通过合并日志命令生成更小的 AOF 文件。 使用 BGREWRITEAOF 命令手动触发重写。 优点 数据持久性更高：AOF 可以记录每一次写操作，支持 “每秒同步” 和 “实时同步” 模式，丢失数据量较少。 AOF 文件是追加的，写入性能较优。 文件可读性强（文本格式），方便调试和修复。 缺点 AOF 文件通常比 RDB 文件大，恢复速度较慢。 写入性能可能受磁盘 IO 的影响。 文件重写过程可能会增加系统负载。 3. 混合持久化 原理 从 Redis 4.0 开始，支持 RDB 和 AOF 的混合持久化。 在混合模式下，Redis 会在重写 AOF 文件时，将内存快照以 RDB 格式写入文件开头，后续的增量数据以 AOF 格式追加。 这样既兼顾了 RDB 快速恢复的优点，又保留了 AOF 的高持久性。 优点 恢复速度更快：RDB 部分快速加载，减少了纯 AOF 文件的重放时间。 数据丢失风险低：结合了 AOF 的增量日志特性。 缺点 需要更多的存储空间，且增加了一定的实现复杂性。 4. 持久化方式的选择 需求场景 推荐持久化方式 数据持久性要求较低，性能优先 RDB 数据持久性要求高 AOF (appendfsync everysec) 恢复速度快且数据可靠性高 混合持久化（RDB + AOF） 临时性数据或完全依赖缓存 不开启持久化（关闭 RDB 和 AOF） Redis 的过期删除策略用于管理过期键（即设置了有效期的键），确保 Redis 内存中的数据不会因为过期而占用不必要的空间。Redis 提供了几种删除过期键的策略，以及与内存管理和过期删除相关的机制。\n1. Redis 过期键管理机制 Redis 中的键过期是通过设置 过期时间（TTL） 来实现的。每个键都可以设置一个生存时间（TTL），当这个时间到达后，Redis 会将这个键标记为过期键。Redis 提供了多种方式来删除这些过期键：\n惰性删除（Lazy deletion） 定期删除（Active deletion） 组合删除策略（惰性删除 + 定期删除） 这些策略的实现确保 Redis 能够以不同的方式删除过期数据，从而在性能和资源管理上取得平衡。\n2. 删除策略详解 2.1 惰性删除（Lazy Deletion） 原理： 惰性删除的策略是，Redis 仅在访问某个键时，检查它是否已过期。如果键已经过期，则会删除该键并返回一个空值。 触发时机： 每次客户端访问一个键时，Redis 会检查该键是否已经过期，如果过期，则删除该键。 特点： 优点： 不会消耗额外的 CPU 资源进行过期键检查，操作简单、低开销。 缺点： 如果过期键没有被访问，那么它就一直占用内存直到 Redis 自动执行定期删除。 2.2 定期删除（Active Deletion） 原理： Redis 会定期进行检查，遍历一定数量的过期键并将它们删除。这是通过一个定时任务实现的，通常 Redis 会每隔一定时间（默认 100 毫秒）扫描一次。 触发时机： Redis 会每隔一段时间（默认每 100 毫秒）扫描部分过期键并删除。 特点： 优点： 可以主动清理过期键，避免因过期键占用内存导致的内存泄漏。 缺点： 定期删除的过程中 Redis 可能会有短暂的性能波动，因为它需要遍历和删除过期键。 2.3 组合删除策略（惰性删除 + 定期删除） Redis 使用 惰性删除 和 定期删除 结合的方式来管理过期键。具体机制如下： 惰性删除： 当客户端访问某个键时，Redis 会检查该键是否过期，并且如果已过期就删除它。 定期删除： Redis 会每 100 毫秒检查和删除部分过期键，确保即使某些过期键没有被访问，也能被删除。 这种策略的设计目的是平衡性能和内存管理，避免过期键占用不必要的内存，同时避免在访问过期键时带来不必要的性能消耗。\n3. 过期键删除策略的配置 Redis 允许对过期删除策略进行一定程度的配置：\n3.1 定期删除的相关参数 hz（Redis 频率设置）\nRedis 定期扫描过期键的频率由 hz 参数控制。默认值为 10，意味着 Redis 每秒执行 10 次周期性的过期键检查。该值越高，过期键清理越频繁，但会增加 CPU 使用。 可以通过 redis.conf 文件或启动参数进行调整： hz 10 # 默认 10，表示每秒检查 10 次 active-expire-effort\nRedis 执行过期删除的工作量（即检查过期键的数量）由 active-expire-effort 参数控制。该值越高，Redis 每次检查过期键的数量越多，从而减少执行多次检查的次数，但会导致性能消耗增大。 该参数的默认值为 1，通常不需要手动修改，除非 Redis 实例有特别高的过期键处理需求。 3.2 内存限制 Redis 支持设置内存限制，当内存达到某个阈值时，Redis 会通过 LRU（最近最少使用） 或 LFU（最不常用） 算法删除键来腾出空间。如果设置了内存限制，并且存在过期的键，Redis 会优先删除过期键，而不是删除其他键。 可以通过以下配置设置 Redis 的最大内存：\nmaxmemory 100mb # 限制 Redis 最大内存为 100MB 同时，还可以指定 Redis 在内存限制达到时如何处理键：\nmaxmemory-policy noeviction # 超过内存限制时不进行任何驱逐 maxmemory-policy allkeys-lru # 使用 LRU 算法从所有键中驱逐 maxmemory-policy volatile-lru # 仅从有过期时间的键中使用 LRU 算法驱逐 4. 常见过期删除配置 Redis 默认使用惰性删除与定期删除相结合的方式，通常情况下无需修改默认配置。但如果需要调整策略，可以通过以下配置来优化性能：\n启用/禁用过期键删除\nRedis 允许通过配置关闭或启用过期键的删除（不推荐关闭过期删除）： stop-writes-on-bgsave-error no # 当 RDB 快照保存失败时，不停止写入（影响过期删除） 控制过期删除的时间范围\n默认情况下，Redis 会每 100 毫秒检查过期键的删除，可以通过调整以下配置控制： active-expire-effort 1 # 设置每次扫描的工作量 5. 总结 Redis 提供了以下三种过期键删除策略：\n惰性删除（Lazy deletion）：只有在访问键时，才会检查并删除过期键。 定期删除（Active deletion）：定期扫描部分过期键并删除。 组合策略（惰性删除 + 定期删除）：Redis 默认使用该策略，即结合了惰性删除和定期删除。 Redis 会每隔一定时间（默认 100 毫秒）扫描并删除过期键，同时也会在访问过期键时进行删除。通过调整 hz 和 active-expire-effort 等配置，可以优化过期键的删除策略，以平衡性能和内存管理。\n在 Go 语言中实现玩家积分排序的 Top N 算法，我们可以通过多种方式来实现。这里将介绍几种常见的方法，包括使用 最小堆（Min-Heap）、排序、和 快速选择（QuickSelect）算法。\n1. 使用最小堆（Min-Heap） 最小堆是一种非常高效的解决方案，特别适合当玩家总数非常大，而 Top N 比较小的情况。最小堆保证了堆顶元素始终是最小的，因此可以在不完全排序的情况下快速找出 Top N 元素。\n思路： 使用 Go 的 heap 包来实现最小堆。 遍历所有玩家，如果堆的大小小于 N，则直接加入堆中。 如果堆已满，且当前玩家的积分大于堆顶元素（最小元素），则替换堆顶元素。 Go 代码实现： package main import ( \"container/heap\" \"fmt\" ) // Player 表示一个玩家的结构体 type Player struct { ID int Score int } // MinHeap 定义一个最小堆结构体 type MinHeap []Player // 实现 heap.Interface 接口 func (h MinHeap) Len() int { return len(h) } func (h MinHeap) Less(i, j int) bool { return h[i].Score \u003c h[j].Score } func (h MinHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } // Push 方法将一个元素推入堆中 func (h *MinHeap) Push(x interface{}) { *h = append(*h, x.(Player)) } // Pop 方法从堆中弹出一个最小元素 func (h *MinHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x } // TopNPlayers 获取前 N 个积分最高的玩家 func TopNPlayers(players []Player, N int) []Player { // 创建一个最小堆 h := \u0026MinHeap{} heap.Init(h) // 遍历玩家列表 for _, player := range players { // 如果堆还没有达到 N 大小 if h.Len() \u003c N { heap.Push(h, player) } else { // 如果堆已满且当前玩家积分大于堆顶的最小值，则替换堆顶 if player.Score \u003e (*h)[0].Score { heap.Pop(h) heap.Push(h, player) } } } // 将堆中的玩家按积分从高到低排序 var result []Player for h.Len() \u003e 0 { result = append(result, heap.Pop(h).(Player)) } // 反转结果，确保按积分从高到低排序 for i, j := 0, len(result)-1; i \u003c j; i, j = i+1, j-1 { result[i], result[j] = result[j], result[i] } return result } func main() { players := []Player{ {ID: 1, Score: 100}, {ID: 2, Score: 200}, {ID: 3, Score: 150}, {ID: 4, Score: 50}, {ID: 5, Score: 120}, } // 获取前 3 名玩家 topPlayers := TopNPlayers(players, 3) for _, player := range topPlayers { fmt.Printf(\"Player ID: %d, Score: %d\\n\", player.ID, player.Score) } } 解释： Player 结构体：用于表示一个玩家，包括玩家 ID 和积分。 MinHeap 结构体：实现了 Go 标准库 heap.Interface 接口，能够支持最小堆操作。Len、Less、Swap、Push 和 Pop 方法是 heap.Interface 的要求。 TopNPlayers 函数： 使用最小堆维护前 N 个最高积分的玩家。 遍历玩家列表，如果堆的大小小于 N，就将玩家加入堆；如果堆已经满了，且当前玩家积分大于堆顶元素，则替换堆顶。 最后将堆中的元素按积分从高到低排序，返回前 N 名玩家。 时间复杂度： 插入操作 heap.Push 和弹出操作 heap.Pop 的时间复杂度为 O(log N)，因此遍历 K 个玩家的总时间复杂度为 O(K log N)。 2. 使用排序（Sorting） 如果数据量不是特别大，且排序操作可以接受，可以直接通过 Go 的内置排序功能对玩家进行排序，之后取前 N 个玩家。\nGo 代码实现： package main import ( \"fmt\" \"sort\" ) // Player 结构体定义 type Player struct { ID int Score int } // 按积分从高到低排序 func TopNPlayers(players []Player, N int) []Player { // 使用 sort.Sort 对玩家按积分排序 sort.Slice(players, func(i, j int) bool { return players[i].Score \u003e players[j].Score }) // 返回前 N 个玩家 if N \u003e len(players) { N = len(players) } return players[:N] } func main() { players := []Player{ {ID: 1, Score: 100}, {ID: 2, Score: 200}, {ID: 3, Score: 150}, {ID: 4, Score: 50}, {ID: 5, Score: 120}, } // 获取前 3 名玩家 topPlayers := TopNPlayers(players, 3) for _, player := range topPlayers { fmt.Printf(\"Player ID: %d, Score: %d\\n\", player.ID, player.Score) } } 解释： 使用 sort.Slice 按照玩家积分从高到低进行排序。 最后返回排序后的前 N 个玩家。 时间复杂度： 排序的时间复杂度是 O(K log K)，其中 K 是玩家总数。 3. 使用快速选择（QuickSelect） QuickSelect 是一种基于快速排序的算法，可以用来在不完全排序的情况下找到第 N 大的元素。它比完全排序更高效，适合大规模数据。\nGo 代码实现： package main import ( \"fmt\" \"math/rand\" ) // Player 结构体定义 type Player struct { ID int Score int } // 快速选择算法：用于找到第 N 大的元素 func quickSelect(players []Player, left, right, N int) []Player { if left == right { return players[:N] } // 随机选择一个枢轴 pivotIndex := rand.Intn(right-left+1) + left pivotIndex = partition(players, left, right, pivotIndex) if N == pivotIndex { return players[:N] } else if N \u003c pivotIndex { return quickSelect(players, left, pivotIndex-1, N) } else { return quickSelect(players, pivotIndex+1, right, N) } } // 分区函数：按照分区值对数组进行分区 func partition(players []Player, left, right, pivotIndex int) int { pivotValue := players[pivotIndex].Score players[pivotIndex], players[right] = players[right], players[pivotIndex] storeIndex := left for i := left; i \u003c right; i++ { if players[i].Score \u003e pivotValue { players[storeIndex], players[i] = players[i], players[storeIndex] storeIndex++ } } players[right], players[storeIndex] = players[storeIndex], players[right] return storeIndex } // TopNPlayers 使用快速选择算法获取前 N 个玩家 func TopNPlayers(players []Player, N int) []Player { return quickSelect(players, 0, len(players)-1, N) } func main() { players := []Player{ {ID: 1, Score: 100}, {ID: 2, Score: 200}, {ID: 3, Score: 150}, {ID: 4, Score: 50}, {ID: 5, Score: 120}, } // 获取前 3 名玩家 topPlayers := TopNPlayers(players, 3) for _, player := range topPlayers { fmt.Printf(\"Player ID: %d, Score: %d\\n\", player.ID, player.Score) } } 解释： quickSelect 使用快速选择算法找到第 N 大的玩家 ，并返回前 N 名玩家。\npartition 函数用于将玩家按积分进行分区。 时间复杂度为 O(K)（平均情况下），但最坏情况下是 O(K²)。 总结 最小堆（Min-Heap）：适用于玩家数较多而 N 较小的情况，时间复杂度为 O(K log N)。 排序（Sorting）：简单直接，适用于数据量不大，时间复杂度为 O(K log K)。 快速选择（QuickSelect）：适用于大数据量，且需要高效地找到 Top N 的场景，平均时间复杂度为 O(K)。 七、Little endian 和 Big endian 上一节已经提到，UCS-2 格式可以存储 Unicode 码（码点不超过0xFFFF）。以汉字严为例，Unicode 码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，这就是 Big endian 方式；25在前，4E在后，这是 Little endian 方式。 Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做\"零宽度非换行空格\"（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。\n如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。\nRedis 提供了多种数据结构，每种数据结构都适用于不同的应用场景。以下是 Redis 中的常用数据结构及其主要用途：\n1. String（字符串） 概述：\nRedis 中最基础的数据结构，存储一个键对应的单个字符串值。 可以存储字符串、整数、浮点数等类型的数据。 操作：\nSET key value：设置键的值。 GET key：获取键的值。 INCR key、DECR key：对键的值自增、自减（数值类型）。 APPEND key value：将值追加到已有的值后面。 应用场景：\n缓存常规字符串数据，例如用户信息、配置数据。 计数器，例如访问量统计。 分布式锁（通过 SETNX 实现）。 2. Hash（哈希） 概述：\n存储键值对集合，类似于 Python 中的字典。 适合存储对象或结构化数据。 操作：\nHSET key field value：设置哈希表的字段值。 HGET key field：获取哈希表中指定字段的值。 HDEL key field：删除哈希表中的字段。 HGETALL key：获取哈希表中的所有字段和值。 应用场景：\n存储用户对象信息，例如：user:1001 -\u003e {name: \"Alice\", age: 25}。 数据结构化存储，例如配置表。 3. List（列表） 概述：\n有序列表，支持从两端进行插入、弹出操作。 本质上是一个双向链表。 操作：\nLPUSH key value、RPUSH key value：从左侧或右侧插入元素。 LPOP key、RPOP key：从左侧或右侧弹出元素。 LRANGE key start stop：获取指定范围内的元素。 应用场景：\n消息队列（结合阻塞操作 BLPOP 或 BRPOP 实现）。 任务列表或日志记录。 实现简单的栈或队列。 4. Set（集合） 概述：\n无序集合，元素不重复。 提供集合运算，如交集、并集、差集等。 操作：\nSADD key value：向集合中添加元素。 SREM key value：移除集合中的元素。 SMEMBERS key：获取集合中的所有元素。 SINTER key1 key2：获取两个集合的交集。 应用场景：\n标签系统：例如记录一个用户的兴趣标签。 共同好友、相似用户等的集合运算。 防止重复，例如记录用户的签到或活动参与。 5. Sorted Set（有序集合） 概述：\n类似于 Set，但每个元素关联一个分值（score），按分值排序。 底层由跳表实现，支持高效的范围查询。 操作：\nZADD key score value：向有序集合中添加元素及其分值。 ZRANGE key start stop [WITHSCORES]：按分值排序后，获取指定范围内的元素。 ZREVRANGE key start stop：按分值降序排序后，获取范围内的元素。 ZREM key value：移除指定的元素。 ZRANK key value：获取元素的排名（从低到高）。 ZCOUNT key min max：统计分值在指定范围内的元素数量。 应用场景：\n排行榜，例如积分排行榜、热度排行榜。 延时队列：利用分值作为时间戳处理延时任务。 数据统计和排序，例如文章点赞数排名。 6. Bitmap（位图） 概述：\n用二进制位表示数据，可以实现大规模数据的状态存储。 基于 String 实现，但提供了按位操作的命令。 操作：\nSETBIT key offset value：设置指定偏移量的位值。 GETBIT key offset：获取指定偏移量的位值。 BITCOUNT key [start end]：统计位值为 1 的数量。 BITOP op destkey key1 key2：对多个 Bitmap 执行按位操作（AND、OR、XOR）。 应用场景：\n用户签到（每天一个二进制位，1 表示签到，0 表示未签到）。 大量布尔值的状态存储，例如黑名单或在线状态。 唯一访客统计（结合布隆过滤器）。 7. HyperLogLog 概述：\n一种基数估算数据结构，用于快速计算集合的基数（去重后的元素数量）。 占用内存固定，约 12 KB，但结果不完全精确，误差约为 0.81%。 操作：\nPFADD key element：向 HyperLogLog 添加元素。 PFCOUNT key：获取基数估算值。 PFMERGE destkey key1 key2：合并多个 HyperLogLog。 应用场景：\n统计网站的 UV（独立访客数）。 去重统计，例如统计某商品的购买用户数量。 8. Stream（流） 概述：\nRedis 的消息队列数据结构，类似于 Kafka 或 RabbitMQ。 可以存储时间序列数据，支持消费组（Consumer Group）。 操作：\nXADD key ID field value：向流中添加消息。 XRANGE key start end：按 ID 范围获取消息。 XREAD COUNT count STREAMS key id：读取消息。 XGROUP CREATE key groupname id：创建消费组。 XREADGROUP GROUP groupname consumer STREAMS key id：从消费组中读取消息。 应用场景：\n消息队列或日志系统。 数据流处理，例如实时监控或事件处理。 总结与对比 数据结构 特点和用途 典型应用场景 String 简单、灵活，适用于存储任意值 缓存数据、计数器、分布式锁 Hash 适合存储结构化数据 存储用户对象、配置数据 List 有序、支持队列和栈操作 消息队列、任务列表 Set 无序、不重复，支持集合运算 标签系统、唯一标识管理 Sorted Set 有序集合，按分值排序 排行榜、延时队列、数据统计 Bitmap 用位操作存储和计算状态数据 签到系统、大规模状态存储 HyperLogLog 基数估算 去重统计、大规模数据的快速统计 Stream 日志和消息队列功能 实时消息系统、事件处理 根据具体需求选择合适的数据结构，可以充分发挥 Redis 的高性能特性。\n1. Struct 可比较的条件 Go 中的 struct 可以用 == 或 != 进行比较，前提是： 所有字段都是可比较的。 可比较的类型包括： 基本类型（如 int、float、string 等）。 指针类型。 可以直接比较的数组（数组元素类型也必须可比较）。 如果 struct 中包含不可比较的字段（如切片 slice、映射 map、函数 func 等），那么整个 struct 是 不可比较的，编译时会报错。\n在 Go 中，context 包用于 上下文管理，它主要解决以下问题：\n协程间的取消信号传递：通过 context，可以向多个协程发送取消信号，优雅地停止协程。 设置超时或截止时间：可以为函数调用链设置超时时间，超时后自动取消操作。 传递元数据：允许在函数调用链中传递一些轻量级的上下文数据。 context 包常用于处理需要控制超时、取消或者传递元数据的并发任务，尤其是在 HTTP 服务、RPC 调用、数据库访问等场景中。\nclient如何实现长链接 HTTP 长连接：通过设置 KeepAlive。 WebSocket：用于全双工通信的长连接。 TCP 长连接：适用于自定义协议和高效通信。 gRPC：基于 HTTP/2，天然支持长连接和多路复用。 实现长连接时，需要注意连接的保活、断开重连和资源管理。 Go 中 Slice 的核心概念 Go 的 slice 是一种 动态数组，提供了灵活且高效的数组操作。它的本质是一个三元组结构：\n指向底层数组的指针。 长度（len）：当前切片的元素数量。 容量（cap）：从切片起始位置到底层数组末尾的最大元素数。 以下是对 slice 的 len、cap、共享底层数组以及扩容机制的详细讲解。\nlen(slice)：返回切片中当前的元素数量。 cap(slice)：返回从切片起始位置到底层数组末尾的容量。 多个切片可以共享一个底层数组。操作一个切片可能会影响其他共享同一底层数组的切片。 当向切片追加元素并且超出容量时，Go 会自动扩容。扩容时：\n分配一个新的底层数组。 将旧切片的内容复制到新数组。 返回新的切片。 扩容规则（大致） 当切片长度小于 1024，通常容量翻倍。 当长度超过 1024，容量会增加至原来的 1.25 倍。 在扩容之前，切片共享底层数组；扩容之后，新切片与原底层数组分离，修改不会互相影响。\n3. 总结：稳定性分类 稳定的排序算法 冒泡排序（Bubble Sort） 插入排序（Insertion Sort） 归并排序（Merge Sort） 基数排序（Radix Sort） 计数排序（Counting Sort） 不稳定的排序算法 快速排序（Quick Sort）\n选择排序（Selection Sort）\n堆排序（Heap Sort）\n401 Unauthorized：表示请求缺乏有效的身份验证凭证，需要提供凭证才能访问资源。 403 Forbidden：表示请求已被理解且验证通过，但服务器明确拒绝该请求，客户端没有权限访\nRaft 算法概述 Raft 算法的核心目标是确保分布式系统中的多个节点在面对节点故障、网络分区等问题时，仍然能够达成一致，保证系统的数据一致性。Raft 算法采用了领导者（Leader）机制，整个系统中的节点分为三种角色：领导者（Leader）、跟随者（Follower） 和 候选者（Candidate）。\nRaft 算法的特点 Raft 算法通过以下几个关键概念和机制来实现一致性：\n领导者选举：\nRaft 使用 领导者选举 来决定哪一个节点作为主节点（Leader）。其他节点会作为 跟随者（Follower）存在。只有领导者才能处理客户端的请求。 如果领导者节点失效，系统会触发选举，选举出一个新的领导者来继续处理请求。 日志复制：\n领导者负责接收客户端请求并将日志条目（客户端的操作）复制到所有跟随者上，确保所有节点的日志一致。 每个节点都有一个日志条目，记录系统的状态变化。Raft 确保了日志的一致性，只有在领导者和大多数节点的日志一致时，才认为日志条目已提交。 心跳机制：\n领导者定期向跟随者发送 心跳，以避免跟随者将领导者误认为失效，并开始进行选举。心跳用于维持领导者的身份。 日志一致性：\nRaft 保证 日志条目的顺序一致性，即在所有节点中，提交的日志条目是顺序一致的。如果某个日志条目在某个节点提交，那么该条目在其他节点也必须在相同的索引处提交。 安全性：\nRaft 保证 日志的一致性和顺序性，即如果某个日志条目已经被提交并且被多数节点确认，那么该条目在未来不会被覆盖或撤销。 如果一个节点的日志已经提交到系统中，它的所有日志条目会在新的领导者出现时保持一致。 集群成员变化：\nRaft 还支持动态地改变集群成员，即可以在不中断服务的情况下增加或删除节点。Raft 通过 联合共识（joint consensus）机制来处理这种变化。 Es MySQL事务 ","wordCount":"15563","inLanguage":"en","datePublished":"2024-11-26T14:22:41Z","dateModified":"2024-11-26T14:22:41Z","author":{"@type":"Person","name":{"email":"axlrose.huang@gmail.com","name":"Axlrose"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://echotrue.github.io/blog/101/backend/"},"publisher":{"@type":"Organization","name":"AXLROSE","logo":{"@type":"ImageObject","url":"https://echotrue.github.io/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css><link rel=stylesheet href=/css/main.min.b18e8501c4f9c51c7bc74c831f88a4705978246e383d68ba514a05459901ef6f.css integrity="sha256-sY6FAcT5xRx7x0yDH4ikcFl4JG44PWi6UUoFRZkB728=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/prism.min.ab059a12f053f9764c2b65f5e83ea3a2e77c9957e453e01e0478a8ab6b11109f.css><script src=/js/prism.min.4efeed559740892c1071317ffd1e799722e52463c486cfb182fdef01622950fc.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/blog>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/series>Series</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/book>Book</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1></h1></header><p><small>November 26, 2024&nbsp;· 15563 words&nbsp;· 32 min</small>
<small></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><ul><li><a href=#tcp>tcp</a></li><li><a href=#1-连接方式>1. <strong>连接方式</strong></a></li><li><a href=#2-可靠性>2. <strong>可靠性</strong></a></li><li><a href=#3-传输效率>3. <strong>传输效率</strong></a></li><li><a href=#4-数据格式>4. <strong>数据格式</strong></a></li><li><a href=#5-应用场景>5. <strong>应用场景</strong></a></li><li><a href=#总结对比表>总结对比表</a></li><li><a href=#2-接口的用处><strong>2. 接口的用处</strong></a></li><li><a href=#总结><strong>总结</strong></a></li></ul></li><li><a href=#1-概念与设计理念><strong>1. 概念与设计理念</strong></a></li><li><a href=#2-性能对比><strong>2. 性能对比</strong></a></li><li><a href=#3-通信方式><strong>3. 通信方式</strong></a></li><li><a href=#4-可扩展性><strong>4. 可扩展性</strong></a></li><li><a href=#5-易用性与编程体验><strong>5. 易用性与编程体验</strong></a></li><li><a href=#6-使用场景><strong>6. 使用场景</strong></a></li><li><a href=#7-运行机制><strong>7. 运行机制</strong></a></li><li><a href=#8-优劣势总结><strong>8. 优劣势总结</strong></a></li><li><a href=#总结-1><strong>总结</strong></a><ul><li><a href=#选择-goroutines-的场景><strong>选择 Goroutines 的场景：</strong></a></li><li><a href=#选择-threads-的场景><strong>选择 Threads 的场景：</strong></a></li></ul></li><li><a href=#gmp-模型的组成><strong>GMP 模型的组成</strong></a></li><li><a href=#gmp-的工作原理><strong>GMP 的工作原理</strong></a><ul><li><a href=#调度过程><strong>调度过程</strong></a></li><li><a href=#运行时组件的交互><strong>运行时组件的交互</strong></a></li></ul></li><li><a href=#gmp-的特点><strong>GMP 的特点</strong></a><ul><li><a href=#1-动态线程管理><strong>1. 动态线程管理</strong></a></li><li><a href=#2-动态栈管理><strong>2. 动态栈管理</strong></a></li><li><a href=#3-工作窃取><strong>3. 工作窃取</strong></a></li><li><a href=#4-全局调度><strong>4. 全局调度</strong></a></li></ul></li><li><a href=#gomaxprocs-和并发控制><strong>GOMAXPROCS 和并发控制</strong></a><ul><li><a href=#影响><strong>影响</strong>：</a></li></ul></li><li><a href=#gmp-模型的优点><strong>GMP 模型的优点</strong></a></li><li><a href=#gmp-调度的缺点><strong>GMP 调度的缺点</strong></a></li><li><a href=#总结-2><strong>总结</strong></a></li><li><a href=#3-数据一致性问题><strong>3. 数据一致性问题</strong></a><ul><li><a href=#问题来源><strong>问题来源</strong></a></li><li><a href=#解决方法><strong>解决方法</strong></a></li></ul></li><li><a href=#5-总结><strong>5. 总结</strong></a></li><li><a href=#mysql-索引建立的基本原则><strong>MySQL 索引建立的基本原则</strong></a></li><li><a href=#1-rdb-持久化><strong>1. RDB 持久化</strong></a><ul><li><a href=#原理><strong>原理</strong></a></li><li><a href=#触发机制><strong>触发机制</strong></a></li><li><a href=#优点><strong>优点</strong></a></li><li><a href=#缺点><strong>缺点</strong></a></li></ul></li><li><a href=#2-aof-持久化><strong>2. AOF 持久化</strong></a><ul><li><a href=#原理-1><strong>原理</strong></a></li><li><a href=#触发机制-1><strong>触发机制</strong></a></li><li><a href=#优点-1><strong>优点</strong></a></li><li><a href=#缺点-1><strong>缺点</strong></a></li></ul></li><li><a href=#3-混合持久化><strong>3. 混合持久化</strong></a><ul><li><a href=#原理-2><strong>原理</strong></a></li><li><a href=#优点-2><strong>优点</strong></a></li><li><a href=#缺点-2><strong>缺点</strong></a></li></ul></li><li><a href=#4-持久化方式的选择><strong>4. 持久化方式的选择</strong></a><ul><li><a href=#1-redis-过期键管理机制><strong>1. Redis 过期键管理机制</strong></a></li></ul></li><li><a href=#2-删除策略详解><strong>2. 删除策略详解</strong></a><ul><li><a href=#21-惰性删除lazy-deletion><strong>2.1 惰性删除（Lazy Deletion）</strong></a></li><li><a href=#22-定期删除active-deletion><strong>2.2 定期删除（Active Deletion）</strong></a></li><li><a href=#23-组合删除策略惰性删除--定期删除><strong>2.3 组合删除策略（惰性删除 + 定期删除）</strong></a></li></ul></li><li><a href=#3-过期键删除策略的配置><strong>3. 过期键删除策略的配置</strong></a><ul><li><a href=#31-定期删除的相关参数><strong>3.1 定期删除的相关参数</strong></a></li><li><a href=#32-内存限制><strong>3.2 内存限制</strong></a></li></ul></li><li><a href=#4-常见过期删除配置><strong>4. 常见过期删除配置</strong></a></li><li><a href=#5-总结-1><strong>5. 总结</strong></a><ul><li><a href=#1-使用最小堆min-heap><strong>1. 使用最小堆（Min-Heap）</strong></a></li><li><a href=#思路><strong>思路：</strong></a></li><li><a href=#go-代码实现><strong>Go 代码实现：</strong></a></li><li><a href=#解释><strong>解释：</strong></a></li><li><a href=#时间复杂度><strong>时间复杂度：</strong></a></li></ul></li><li><a href=#2-使用排序sorting><strong>2. 使用排序（Sorting）</strong></a><ul><li><a href=#go-代码实现-1><strong>Go 代码实现：</strong></a></li><li><a href=#解释-1><strong>解释：</strong></a></li><li><a href=#时间复杂度-1><strong>时间复杂度：</strong></a></li></ul></li><li><a href=#3-使用快速选择quickselect><strong>3. 使用快速选择（QuickSelect）</strong></a><ul><li><a href=#go-代码实现-2><strong>Go 代码实现：</strong></a></li><li><a href=#解释-2><strong>解释：</strong></a></li></ul></li><li><a href=#总结-3><strong>总结</strong></a></li><li><a href=#七little-endian-和-big-endian><strong>七、Little endian 和 Big endian</strong></a></li><li><a href=#1-string字符串><strong>1. String（字符串）</strong></a></li><li><a href=#2-hash哈希><strong>2. Hash（哈希）</strong></a></li><li><a href=#3-list列表><strong>3. List（列表）</strong></a></li><li><a href=#4-set集合><strong>4. Set（集合）</strong></a></li><li><a href=#5-sorted-set有序集合><strong>5. Sorted Set（有序集合）</strong></a></li><li><a href=#6-bitmap位图><strong>6. Bitmap（位图）</strong></a></li><li><a href=#7-hyperloglog><strong>7. HyperLogLog</strong></a></li><li><a href=#8-stream流><strong>8. Stream（流）</strong></a></li><li><a href=#总结与对比><strong>总结与对比</strong></a><ul><li><a href=#1-struct-可比较的条件><strong>1. Struct 可比较的条件</strong></a></li><li><a href=#client如何实现长链接>client如何实现长链接</a></li><li><a href=#go-中-slice-的核心概念><strong>Go 中 Slice 的核心概念</strong></a></li><li><a href=#3-总结稳定性分类><strong>3. 总结：稳定性分类</strong></a></li><li><a href=#raft-算法概述>Raft 算法概述</a></li><li><a href=#raft-算法的特点>Raft 算法的特点</a></li></ul></li></ul></nav></div><section class=blog-content><h3 id=tcp>tcp</h3><h4 id=三次握手>三次握手</h4><p>第一次握手
客户端将标志位SYN置1，随机产生一个值seq=J，并将数据包发给服务器Client进入SYN SENT状态，等待Server确认
万
第二次握手
服务器收到数据包后标志位SY=1知道客户端请求建立连接，服务器将标志位SYN和ACK都置1，随机产生一个值，并将数据包发给客户端确认连接请求，服务器进入SYNRCVD状态
第三次握手
客户端收到确认后若ACK为1，则将该数据包发送给服务器，服务器检查ACK为1则连接建立成功，客户端与服务器进入ESTABLISHED状态完成三次握手，可以传输数据</p><p>问题1:为什么建立连接是三次握手，四次不可以吗
第一次握手:
客户(Client)什么都不能确认
服务器(Server)确认了对方发送正常
第二次握手:
Client确认:自己发送/接收正常，对方发送/接收正常
服务器确认:自己接收正常，对方发送正常
第三次握手:
Client确认:自己发送/接收正常，对方发送/接收正常
Server确认:自己发送/接收正常，对方发送/接收正常
所以通过三次握手确认双方收发功能都正常，四次也可以但是显得比较多余。</p><h4 id=四次挥手>四次挥手</h4><p>第一次挥手：</p><p>Clien发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p><p>第二次挥手：</p><p>Server收到FIN后，发送一个ACK给Client,Server进入CLOSE_WAIT状态。</p><p>第三次挥手：</p><p>Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p><p>第四次挥手：</p><p>Client收到FIN后，Client进入TIME_WAIT状态，发送ACK给Server，Server进入CLOSED状态，完成四次握手。</p><p>问题：为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
建立连接</p><p>因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。</p><p>关闭连接</p><p>当收到对方的FIN报文时，仅表示对方不再发送数据但还能接收收据，我们也未必把全部数据都发给了对方，所以我们可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方表示同意关闭连接。因此我们的ACK和FIN一般会分开发送。</p><h4 id=tcp和udp的区别>tcp和udp的区别</h4><p>TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种主要的传输层协议，各自适用于不同的应用场景。以下是两者的主要区别：</p><h3 id=1-连接方式>1. <strong>连接方式</strong></h3><ul><li><p><strong>TCP（面向连接）：</strong></p><ul><li>在数据传输之前需要建立连接（三次握手）。</li><li>传输结束后需要释放连接（四次挥手）。</li><li>提供可靠的传输，适合需要数据完整性保证的场景。</li></ul></li><li><p><strong>UDP（无连接）：</strong></p><ul><li>不需要建立和释放连接。</li><li>直接发送数据，无需握手。</li><li>是一种不可靠传输协议，适合对速度要求高且可以容忍丢包的场景。</li></ul></li></ul><hr><h3 id=2-可靠性>2. <strong>可靠性</strong></h3><ul><li><p><strong>TCP：</strong></p><ul><li>提供可靠的数据传输。</li><li>包含错误校验、重传机制、流量控制和拥塞控制。</li><li>保证数据的顺序性，不会出现数据乱序。</li></ul></li><li><p><strong>UDP：</strong></p><ul><li>不保证数据的可靠性。</li><li>没有重传机制，可能会丢包或乱序。</li><li>没有流量控制和拥塞控制，适合实时性要求高的应用。</li></ul></li></ul><hr><h3 id=3-传输效率>3. <strong>传输效率</strong></h3><ul><li><p><strong>TCP：</strong></p><ul><li>由于需要建立连接、确认数据、处理重传和流量控制，开销较大，传输速度较慢。</li></ul></li><li><p><strong>UDP：</strong></p><ul><li>传输过程简单，无需确认和重传，效率更高，适合实时性强的场景。</li></ul></li></ul><hr><h3 id=4-数据格式>4. <strong>数据格式</strong></h3><ul><li><p><strong>TCP：</strong></p><ul><li>数据以流的形式传输，没有明确的消息边界。</li><li>适合连续的数据传输，如文件传输和长时间连接。</li></ul></li><li><p><strong>UDP：</strong></p><ul><li>数据以数据报（Datagram）的形式发送，每个报文独立。</li><li>适合短小的数据传输，如请求-响应模型。</li></ul></li></ul><hr><h3 id=5-应用场景>5. <strong>应用场景</strong></h3><ul><li><p><strong>TCP：</strong></p><ul><li>适用于对数据可靠性要求高的场景：<ul><li>HTTP/HTTPS（网页浏览）</li><li>FTP（文件传输）</li><li>SMTP（邮件传输）</li></ul></li></ul></li><li><p><strong>UDP：</strong></p><ul><li>适用于对实时性要求高的场景：<ul><li>DNS查询</li><li>视频会议（如Zoom）</li><li>在线游戏</li><li>流媒体传输</li></ul></li></ul></li></ul><hr><h3 id=总结对比表>总结对比表</h3><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接</td><td>无连接</td></tr><tr><td>可靠性</td><td>可靠</td><td>不可靠</td></tr><tr><td>传输效率</td><td>较低</td><td>较高</td></tr><tr><td>数据顺序</td><td>保证顺序</td><td>不保证顺序</td></tr><tr><td>流量控制与拥塞控制</td><td>有</td><td>无</td></tr><tr><td>数据传输方式</td><td>流式传输</td><td>报文传输</td></tr><tr><td>典型应用场景</td><td>文件传输、网页、邮件</td><td>视频、语音、游戏、DNS</td></tr></tbody></table><p>根据需求选择适合的协议可以更好地优化系统性能和用户体验。</p><h4 id=golang-接口>golang 接口</h4><p>接口的作用</p><ul><li><p><strong>抽象和解耦</strong><br>接口用于定义行为，而不是实现。通过接口可以实现代码的模块化和解耦，使程序更加灵活和可扩展。</p></li><li><p><strong>多态</strong><br>Go语言通过接口实现了多态，一个接口可以被多个不同类型实现，这使得代码更加通用。</p></li><li><p><strong>统一方法调用</strong><br>定义接口后，调用代码不需要知道具体类型，只需要依赖接口类型。</p></li></ul><hr><h3 id=2-接口的用处><strong>2. 接口的用处</strong></h3><ul><li><p><strong>设计灵活的代码结构</strong></p><ul><li>通过接口定义不同模块的交互方式，而无需了解其内部实现。</li><li>提高代码的可测试性，因为可以用接口模拟不同的实现进行测试。</li></ul></li><li><p><strong>实现依赖倒置</strong><br>高层模块依赖接口，而不是具体实现，符合面向接口编程的原则。</p></li><li><p><strong>便于扩展</strong><br>新增实现类型时无需更改现有代码，只需要实现接口即可。</p></li><li><p><strong>标准化行为</strong><br>定义一组方法契约，不同类型只要实现这些方法，就可以统一处理。</p></li></ul><h3 id=总结><strong>总结</strong></h3><p>接口是Go语言的重要特性，用于实现抽象、解耦和多态。通过定义行为接口，程序可以实现灵活的模块化设计，同时增强代码的可扩展性和测试性。合理地设计和使用接口是编写优雅Go代码的关键。</p><h4 id=golang-空结构体>golang 空结构体</h4><p>在 <strong>Golang</strong> 中，空结构体（<code>struct{}</code>）是一种特别轻量级的类型，具有一些独特的性质和用途。以下是关于空结构体的详细解答：</p><ul><li><strong>用途</strong>：<ol><li>节省内存的占位符，用于集合、标记等。</li><li>通信信号传递。</li><li>用于轻量级对象实现。</li></ol></li><li><strong>内存</strong>：
空结构体本身不占用内存，但作为切片或数组元素时会有附加开销。</li><li><strong>可比较性</strong>：
空结构体是可比较的，并且所有空结构体值总是相等。</li></ul><p>使用空结构体可以在合适的场景下有效减少内存开销，是 Go 语言中一个非常实用的设计模式。</p><h4 id=go默认参数和可选参数>go默认参数和可选参数</h4><p>golang不直接支持默认参数或可选参数，可以间接通过边长参数或者结构体封装参数实现类似的功能</p><p>Golang 的协程（<strong>goroutines</strong>）和传统线程（<strong>threads</strong>）虽然都用于并发编程，但在设计理念、实现方式和性能表现上有显著差异。以下是对它们的详细比较：</p><hr><h2 id=1-概念与设计理念><strong>1. 概念与设计理念</strong></h2><table><thead><tr><th><strong>属性</strong></th><th><strong>Goroutines</strong></th><th><strong>Threads</strong></th></tr></thead><tbody><tr><td><strong>本质</strong></td><td>用户态轻量级线程，由 Go 运行时调度。</td><td>内核态线程，由操作系统调度。</td></tr><tr><td><strong>调度</strong></td><td>Go 运行时使用 M:N 调度（多个 goroutine 映射到多个 OS 线程）。</td><td>由操作系统内核调度，通常是 1:1 的线程模型。</td></tr><tr><td><strong>启动开销</strong></td><td>极低，创建一个 goroutine 的开销约 2KB。</td><td>较高，创建线程需要分配栈内存（通常 1MB）。</td></tr><tr><td><strong>栈大小</strong></td><td>动态调整，初始为 2KB，可增长到 GB 级别。</td><td>固定大小，通常为 1MB，可能导致内存浪费。</td></tr></tbody></table><hr><h2 id=2-性能对比><strong>2. 性能对比</strong></h2><table><thead><tr><th><strong>属性</strong></th><th><strong>Goroutines</strong></th><th><strong>Threads</strong></th></tr></thead><tbody><tr><td><strong>创建速度</strong></td><td>更快，数百万 goroutines 可并发运行。</td><td>较慢，系统对线程数有限制（通常是数千个）。</td></tr><tr><td><strong>切换成本</strong></td><td>低，Go 运行时管理切换，避免了用户态与内核态切换的开销。</td><td>高，线程切换涉及内核态与用户态的上下文切换。</td></tr><tr><td><strong>资源利用</strong></td><td>更高效，轻量级，适合高并发场景。</td><td>较重，线程需要更多的内存和 CPU 资源。</td></tr></tbody></table><hr><h2 id=3-通信方式><strong>3. 通信方式</strong></h2><table><thead><tr><th><strong>属性</strong></th><th><strong>Goroutines</strong></th><th><strong>Threads</strong></th></tr></thead><tbody><tr><td><strong>通信机制</strong></td><td>推荐通过 <strong>通道（channel）</strong> 进行通信，鼓励“不要通过共享内存通信，而是通过通信共享内存”。</td><td>通常通过 <strong>共享内存</strong>（如锁、条件变量）进行通信。</td></tr><tr><td><strong>数据安全性</strong></td><td>Channel 提供内置的同步机制，数据交换更安全。</td><td>必须手动使用锁（如互斥锁、读写锁）保护共享数据。</td></tr><tr><td><strong>开发复杂度</strong></td><td>更低，goroutines + channels 使并发代码更直观。</td><td>更高，需要手动管理线程安全。</td></tr></tbody></table><hr><h2 id=4-可扩展性><strong>4. 可扩展性</strong></h2><table><thead><tr><th><strong>属性</strong></th><th><strong>Goroutines</strong></th><th><strong>Threads</strong></th></tr></thead><tbody><tr><td><strong>并发数量</strong></td><td>支持数百万级的 goroutines。</td><td>通常支持数千级的线程，受限于内存和操作系统开销。</td></tr><tr><td><strong>扩展性</strong></td><td>运行时自带调度器（GMP 模型），动态调整线程数以适应系统负载。</td><td>受限于操作系统调度能力，多线程编程复杂且效率较低。</td></tr></tbody></table><hr><h2 id=5-易用性与编程体验><strong>5. 易用性与编程体验</strong></h2><table><thead><tr><th><strong>属性</strong></th><th><strong>Goroutines</strong></th><th><strong>Threads</strong></th></tr></thead><tbody><tr><td><strong>易用性</strong></td><td>语法简单（<code>go func()</code>），开发者无需管理栈和调度细节。</td><td>较复杂，需要管理线程创建、销毁、同步等操作。</td></tr><tr><td><strong>代码简洁性</strong></td><td>Goroutines + channels 提供更高层次的抽象。</td><td>手动处理锁、条件变量，代码容易变得复杂且难以维护。</td></tr><tr><td><strong>错误恢复</strong></td><td><code>recover</code> 机制可以处理 goroutines 中的 panic。</td><td>线程崩溃通常会导致整个程序崩溃。</td></tr></tbody></table><hr><h2 id=6-使用场景><strong>6. 使用场景</strong></h2><table><thead><tr><th><strong>属性</strong></th><th><strong>Goroutines</strong></th><th><strong>Threads</strong></th></tr></thead><tbody><tr><td><strong>适用场景</strong></td><td>高并发、轻量级任务（如 Web 服务、消息处理）。</td><td>CPU 密集型任务，或需要操作系统级特性的场景（如硬件交互）。</td></tr><tr><td><strong>场景限制</strong></td><td>不适合需要直接操作线程特性（如线程优先级、线程绑定）的场景。</td><td>多线程适合需要精细控制的底层编程。</td></tr></tbody></table><hr><h2 id=7-运行机制><strong>7. 运行机制</strong></h2><ul><li><p><strong>Goroutines</strong><br>Go 的 GMP 模型：</p><ul><li><strong>G</strong>: Goroutines，表示协程。</li><li><strong>M</strong>: Machine，表示 OS 线程。</li><li><strong>P</strong>: Processor，表示逻辑处理器，用于执行 goroutines。</li><li>Go 运行时动态将 Goroutines 分配到多个线程上执行，且会自动调度，避免了开发者直接操作线程的复杂性。</li></ul></li><li><p><strong>Threads</strong></p><ul><li>由操作系统的线程调度器管理。</li><li>开销大，线程调度和切换成本较高。</li></ul></li></ul><hr><h2 id=8-优劣势总结><strong>8. 优劣势总结</strong></h2><table><thead><tr><th><strong>属性</strong></th><th><strong>Goroutines</strong></th><th><strong>Threads</strong></th></tr></thead><tbody><tr><td><strong>优势</strong></td><td>轻量、高效、简单易用、扩展性强</td><td>功能强大、控制细粒度高</td></tr><tr><td><strong>劣势</strong></td><td>不支持线程优先级、依赖 Go 运行时</td><td>创建和管理开销高，复杂度大</td></tr></tbody></table><hr><h2 id=总结-1><strong>总结</strong></h2><h3 id=选择-goroutines-的场景><strong>选择 Goroutines 的场景：</strong></h3><ul><li>高并发、高 I/O 的应用（如 Web 服务、微服务）。</li><li>对内存占用和切换开销敏感的应用。</li><li>希望代码更加简洁、易读、易维护。</li></ul><h3 id=选择-threads-的场景><strong>选择 Threads 的场景：</strong></h3><ul><li>操作系统级别的任务（如硬件交互、系统调用）。</li><li>需要特定线程特性（如优先级、绑定核心）。</li><li>多语言混合开发或现有项目需要兼容多线程模型。</li></ul><p>总之，<strong>Goroutines</strong> 是 Go 语言的核心优势之一，适合大多数高并发场景，而 <strong>Threads</strong> 仍然在需要底层控制的应用中占有一席之地。</p><p>在 Go 语言中，<strong>GMP 模型</strong>是其运行时（runtime）用来调度和管理并发的核心机制。GMP 是一种高效的 M:N 调度模型，其中多个 Goroutine 映射到多个操作系统线程运行，旨在最大化 CPU 的利用率并简化开发者管理并发的复杂性。</p><hr><h2 id=gmp-模型的组成><strong>GMP 模型的组成</strong></h2><p>GMP 由三个关键组件构成：</p><ol><li><p><strong>G (Goroutine)</strong></p><ul><li>表示 Go 语言中的协程，是由 Go 运行时管理的轻量级线程。</li><li>每个 Goroutine 包含栈、任务函数以及调度所需的状态信息。</li><li>Goroutine 的栈初始为 2KB，可动态增长和收缩（相比传统线程的固定栈大小更加节省内存）。</li></ul></li><li><p><strong>M (Machine)</strong></p><ul><li>表示操作系统线程（OS Thread），负责执行 Goroutine。</li><li>每个 M 对应一个操作系统线程，但一个 M 可以执行多个 G。</li><li>M 由 Go 运行时管理，避免了操作系统线程的直接调度开销。</li></ul></li><li><p><strong>P (Processor)</strong></p><ul><li>表示逻辑处理器，是 G 和 M 之间的桥梁。</li><li>P 决定了 Goroutine 能够并发运行的最大数量，<code>P</code> 的数量由 <code>GOMAXPROCS</code> 环境变量决定。</li><li>每个 P 持有一个 Goroutine 队列，M 从 P 的队列中获取 G 运行。</li></ul></li></ol><hr><h2 id=gmp-的工作原理><strong>GMP 的工作原理</strong></h2><h3 id=调度过程><strong>调度过程</strong></h3><ol><li><p><strong>创建 Goroutine (G)</strong>：</p><ul><li>当使用 <code>go</code> 关键字启动一个协程时，会创建一个新的 G，放入到某个 P 的队列中等待执行。</li></ul></li><li><p><strong>执行 Goroutine (G)</strong>：</p><ul><li>一个 M 从 P 的本地队列中取出 G 并执行。</li><li>如果本地队列为空，M 会从全局队列或其他 P 的队列中窃取 Goroutine。</li></ul></li><li><p><strong>阻塞与切换</strong>：</p><ul><li>如果一个 Goroutine 阻塞（如系统调用），其绑定的 M 会解除与 P 的绑定，释放 P 供其他 M 使用。</li><li>被阻塞的 M 会等待操作完成后返回全局线程池。</li></ul></li><li><p><strong>工作窃取</strong>：</p><ul><li>当一个 P 的本地队列为空时，运行时会尝试从其他 P 的队列中窃取任务（work stealing），确保资源利用率最大化。</li></ul></li></ol><hr><h3 id=运行时组件的交互><strong>运行时组件的交互</strong></h3><ul><li><p><strong>G</strong> 与 <strong>P</strong>：</p><ul><li>G 需要绑定一个 P 才能被调度运行。</li><li>P 是逻辑处理器，管理 Goroutine 的本地队列。</li></ul></li><li><p><strong>M</strong> 与 <strong>P</strong>：</p><ul><li>M 需要与 P 绑定后才能运行 G。</li><li>当 M 执行 G 时，P 提供调度上下文和任务队列。</li></ul></li><li><p><strong>全局队列</strong>：</p><ul><li>新创建的 Goroutine 可能会先进入全局队列，当 P 的本地队列有空位时再从全局队列拉取任务。</li></ul></li></ul><hr><h2 id=gmp-的特点><strong>GMP 的特点</strong></h2><h3 id=1-动态线程管理><strong>1. 动态线程管理</strong></h3><ul><li>M（OS 线程）的数量不固定，Go 运行时根据负载情况动态增加或减少线程数。</li><li>阻塞的线程会释放 P，避免因阻塞操作而浪费处理器资源。</li></ul><h3 id=2-动态栈管理><strong>2. 动态栈管理</strong></h3><ul><li>Goroutine 的栈初始为 2KB，可根据需要动态增长（最大可到 1GB）。</li><li>相比线程的固定栈（通常 1MB），大幅减少了内存占用。</li></ul><h3 id=3-工作窃取><strong>3. 工作窃取</strong></h3><ul><li>当一个 P 的任务队列为空时，会尝试从其他 P 的任务队列中窃取任务，从而平衡负载，提高 CPU 利用率。</li></ul><h3 id=4-全局调度><strong>4. 全局调度</strong></h3><ul><li>Go 运行时维护一个全局任务队列，P 的本地队列不足时可以从全局队列中获取任务。</li></ul><hr><h2 id=gomaxprocs-和并发控制><strong>GOMAXPROCS 和并发控制</strong></h2><ul><li><code>GOMAXPROCS</code> 控制逻辑处理器（P）的数量，默认值为运行环境中的 CPU 核心数。</li><li>可以通过 <code>runtime.GOMAXPROCS</code> 或环境变量修改：<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>GOMAXPROCS</span>(<span style=color:#ae81ff>4</span>) <span style=color:#75715e>// 设置逻辑处理器数量为 4
</span></span></span></code></pre></div></li></ul><h3 id=影响><strong>影响</strong>：</h3><ul><li>增大 <code>GOMAXPROCS</code>：<ul><li>提高并发能力，但可能引入更多线程切换的开销。</li></ul></li><li>减小 <code>GOMAXPROCS</code>：<ul><li>限制并发 Goroutine 的数量，有助于降低竞争，但可能导致资源利用不足。</li></ul></li></ul><hr><h2 id=gmp-模型的优点><strong>GMP 模型的优点</strong></h2><ol><li><p><strong>高效的调度</strong>：</p><ul><li>GMP 模型避免了直接使用线程带来的高开销，通过用户态调度实现轻量级并发。</li></ul></li><li><p><strong>优异的资源利用率</strong>：</p><ul><li>动态线程管理和工作窃取机制确保 Goroutine 能最大程度地利用系统资源。</li></ul></li><li><p><strong>简化并发编程</strong>：</p><ul><li>开发者无需直接管理线程，<code>go</code> 关键字和 channel 机制提供了简单直观的并发抽象。</li></ul></li></ol><hr><h2 id=gmp-调度的缺点><strong>GMP 调度的缺点</strong></h2><ol><li><p><strong>依赖 Go 运行时</strong>：</p><ul><li>GMP 的调度完全依赖 Go 运行时，在某些高性能场景下不如手动优化的线程池。</li></ul></li><li><p><strong>非实时性</strong>：</p><ul><li>Goroutine 的调度是软实时的，无法保证实时任务的绝对响应时间。</li></ul></li><li><p><strong>复杂性</strong>：</p><ul><li>虽然对开发者透明，但 GMP 模型的内部调度逻辑相对复杂，可能在极端情况下引发性能问题。</li></ul></li></ol><hr><h2 id=总结-2><strong>总结</strong></h2><p>GMP 模型是 Go 语言并发编程的核心，具有以下关键特性：</p><ul><li><strong>轻量级并发</strong>：Goroutines 运行时轻量，启动和切换开销低。</li><li><strong>自动调度</strong>：通过 P 控制并发数量，M:N 调度避免了操作系统线程的高开销。</li><li><strong>高效的负载均衡</strong>：通过工作窃取机制优化资源分配。</li></ul><p>通过 GMP，Go 实现了高效的并发处理，特别适合 I/O 密集型和高并发场景，如 Web 服务、分布式系统等。</p><p>在实际应用中，<strong>Redis</strong> 和 <strong>MySQL</strong> 通常被组合使用：</p><ul><li><strong>MySQL</strong> 作为主存储，提供可靠的持久化存储能力。</li><li><strong>Redis</strong> 作为缓存，提供高性能的读取服务。</li></ul><p>为了保证两者数据的一致性，常见的同步方案包括主动同步、被动同步和混合模式。以下是详细的实现方式：</p><p>主动同步
主动同步由业务逻辑控制，典型步骤是：</p><ol><li><strong>更新数据库：</strong> 数据被写入 MySQL。</li><li><strong>同步缓存：</strong> 数据同时或随后同步到 Redis。</li></ol><p>被动同步**
在被动同步模式中，Redis 不主动同步数据，而是根据需要从 MySQL 中加载数据。<br>这是典型的 <strong>缓存失效策略</strong>，即“从缓存中取不到数据时才查询数据库”。</p><p>混合模式**
在高并发场景下，可以结合主动同步和被动同步，既保证性能又提升一致性。<br>例如：</p><ul><li><strong>热点数据：</strong> 使用主动同步，更新时同步到 Redis。</li><li><strong>冷门数据：</strong> 使用被动同步，按需加载到 Redis。</li></ul><hr><h2 id=3-数据一致性问题><strong>3. 数据一致性问题</strong></h2><h3 id=问题来源><strong>问题来源</strong></h3><ol><li><strong>缓存与数据库异步更新：</strong> MySQL 更新后，Redis 缓存可能未及时更新。</li><li><strong>缓存穿透、雪崩和击穿：</strong><ul><li><strong>穿透：</strong> 查询一个不存在的数据，会导致频繁访问 MySQL。</li><li><strong>雪崩：</strong> 缓存大规模失效时，所有请求直接访问 MySQL。</li><li><strong>击穿：</strong> 某些热点数据突然失效，大量请求同时访问数据库。</li></ul></li></ol><h3 id=解决方法><strong>解决方法</strong></h3><h4 id=31-缓存更新策略><strong>3.1 缓存更新策略</strong></h4><ul><li><strong>写后删除：</strong><br>更新 MySQL 数据后，删除 Redis 中的旧数据。<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>updateData</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 更新 MySQL 数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>updateMySQL</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 删除 Redis 缓存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>deleteRedis</span>(<span style=color:#a6e22e>key</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Failed to delete Redis key: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><strong>写后更新：</strong><br>更新 MySQL 后，立即将新数据写入 Redis。</li></ul><h4 id=32-防止缓存穿透><strong>3.2 防止缓存穿透</strong></h4><ul><li><strong>设置空值缓存：</strong> 对不存在的数据写入空值到 Redis，避免频繁访问数据库。</li><li><strong>布隆过滤器：</strong> 使用布隆过滤器拦截无效查询。</li></ul><h4 id=33-防止缓存雪崩><strong>3.3 防止缓存雪崩</strong></h4><ul><li><strong>缓存预热：</strong> 在系统启动时提前将热点数据加载到缓存。</li><li><strong>随机过期时间：</strong> 缓存的过期时间加上随机值，避免大规模同时失效。</li></ul><h4 id=34-防止缓存击穿><strong>3.4 防止缓存击穿</strong></h4><ul><li><strong>热点数据加锁：</strong> 缓存失效时，使用分布式锁限制同时查询 MySQL。</li><li><strong>永久缓存：</strong> 对特别热点的数据设置为永久缓存，同时异步更新。</li></ul><h2 id=5-总结><strong>5. 总结</strong></h2><p>Redis 与 MySQL 数据同步有多种方式，需要根据场景选择合适的策略：</p><table><thead><tr><th><strong>需求</strong></th><th><strong>推荐策略</strong></th></tr></thead><tbody><tr><td>高一致性要求</td><td>主动同步 + 写后删除或写后更新。</td></tr><tr><td>高性能、低延迟</td><td>被动同步 + 缓存失效重建。</td></tr><tr><td>高并发、热点数据</td><td>混合模式，热点数据主动同步，冷门数据被动同步。</td></tr><tr><td>数据变更实时性高</td><td>借助 Canal 或消息队列实现实时同步。</td></tr></tbody></table><p>每种方案都有优缺点，实际应用中需要根据业务特点、性能要求和一致性需求进行权衡和选择。</p><h2 id=mysql-索引建立的基本原则><strong>MySQL 索引建立的基本原则</strong></h2><ol><li><p><strong>基于查询需求建立索引</strong></p><ul><li>索引的核心目的是优化查询，尤其是频繁使用的查询语句（如 <code>SELECT</code>）。</li><li>分析查询模式，优先为 <strong>WHERE 条件、JOIN 条件、GROUP BY 和 ORDER BY 列</strong>建立索引。</li></ul></li><li><p><strong>选择性高的列优先建立索引</strong></p><ul><li>列的选择性（区分度）是指不重复值的比例，公式为： 选择性=列中不重复值的数量总行数\text{选择性} = \frac{\text{列中不重复值的数量}}{\text{总行数}}选择性=总行数列中不重复值的数量​</li><li>选择性高的列（如唯一标识符）更适合作为索引，因为它能快速缩小查询范围。<br>对于选择性低的列（如性别、布尔值），索引效果不佳。</li></ul></li><li><p><strong>复合索引优于单列索引</strong></p><ul><li>对涉及多列的查询（如多条件查询）使用复合索引可以避免多个单列索引的性能不足。</li><li>复合索引遵循 <strong>最左前缀匹配原则</strong>：<ul><li>如果有 <code>(a, b, c)</code> 的复合索引，可以支持查询 <code>a</code>，<code>a AND b</code>，<code>a AND b AND c</code>。</li><li>但查询中未使用索引的最左列时（如 <code>b AND c</code>），索引失效。</li></ul></li></ul></li><li><p><strong>避免过多或冗余的索引</strong></p><ul><li>每个索引都会增加写操作的成本（插入、更新、删除时需要维护索引）。</li><li>冗余索引（功能重复的索引）会浪费存储资源，应尽量减少。</li></ul></li><li><p><strong>覆盖索引</strong></p><ul><li><p><strong>覆盖索引</strong>是指查询所需的数据完全存储在索引中，不需要回表查询。</p></li><li><p>覆盖索引通常能显著提高查询性能，特别是在只读场景中。</p><p>sql</p><p>复制代码</p><p><code>CREATE INDEX idx_user_name ON users (name, email); SELECT name, email FROM users WHERE name = 'John';</code></p></li></ul></li><li><p><strong>避免对频繁更新的列建立索引</strong></p><ul><li>索引需要随列值更新而更新，因此频繁变化的列（如时间戳、状态）会增加维护开销。</li></ul></li><li><p><strong>避免对低基数列建立索引</strong></p><ul><li>低基数列（如布尔值、性别）索引无法有效缩小查询范围，通常对性能提升有限。</li><li>如果查询中涉及低基数列，建议结合高基数列或其他优化手段。</li></ul></li><li><p><strong>为外键列建立索引</strong></p><ul><li>外键关联的列通常用于 JOIN 操作，建立索引可加速关联查询。</li></ul></li><li><p><strong>谨慎使用全文索引和前缀索引</strong></p><ul><li><p><strong>全文索引</strong>适用于大文本字段的搜索（如文章内容），但仅在特殊场景使用。</p></li><li><p><strong>前缀索引</strong>适用于长度较长的字符串列（如 URL、邮件地址），但可能导致查询精度降低。</p><p>sql</p><p>复制代码</p><p><code>CREATE INDEX idx_email_prefix ON users (email(10));</code></p></li></ul></li><li><p><strong>分区和分库分表情况下的索引</strong></p><ul><li>在分区表中，建议在分区键上建立索引。</li><li>在分库分表场景下，需考虑全局唯一性需求，避免对跨库 JOIN 的列建立过多索引。</li></ul></li></ol><p>Redis 提供了两种主要的持久化方式，用于将内存中的数据保存到磁盘，防止数据丢失：</p><ol><li><strong>RDB（Redis DataBase）快照持久化</strong></li><li><strong>AOF（Append Only File）日志持久化</strong></li></ol><p>此外，Redis 还支持 <strong>混合持久化</strong>，结合了 RDB 和 AOF 的优势。</p><hr><h2 id=1-rdb-持久化><strong>1. RDB 持久化</strong></h2><h3 id=原理><strong>原理</strong></h3><ul><li>RDB 持久化会定期将 Redis 中的数据快照保存到二进制文件（默认文件名为 <code>dump.rdb</code>）。</li><li>它是一次性保存 Redis 数据的完整副本。</li></ul><h3 id=触发机制><strong>触发机制</strong></h3><p>RDB 可以通过两种方式触发：</p><ol><li><p><strong>自动触发（配置文件）</strong></p><ul><li><p>Redis 配置文件中可以设置保存快照的条件：</p><p>bash</p><p>复制代码</p><p><code>save 900 1 # 900秒内（15分钟）至少有1次写操作 save 300 10 # 300秒内（5分钟）至少有10次写操作 save 60 10000 # 60秒内至少有10000次写操作</code></p></li><li><p>满足条件时，Redis 自动执行 RDB 快照。</p></li></ul></li><li><p><strong>手动触发</strong></p><ul><li>使用 <code>SAVE</code> 命令：阻塞 Redis 服务并立即生成 RDB 文件。</li><li>使用 <code>BGSAVE</code> 命令：以非阻塞方式在后台生成 RDB 文件。</li></ul></li></ol><h3 id=优点><strong>优点</strong></h3><ul><li>RDB 文件体积小，适合备份和快速迁移。</li><li>恢复数据速度快（加载一个完整的快照）。</li><li>对 Redis 性能的影响较小，因其是周期性操作。</li></ul><h3 id=缺点><strong>缺点</strong></h3><ul><li><strong>数据丢失风险较高</strong>：快照是定期生成的，若 Redis 崩溃，可能丢失最后一次快照之后的数据。</li><li>快照生成过程可能较慢，占用大量的 CPU 和内存。</li></ul><hr><h2 id=2-aof-持久化><strong>2. AOF 持久化</strong></h2><h3 id=原理-1><strong>原理</strong></h3><ul><li>AOF 持久化记录每个写操作的命令日志（以 Redis 协议保存），并追加到文件（默认文件名为 <code>appendonly.aof</code>）。</li><li>当 Redis 重启时，通过重放这些命令重建数据。</li></ul><h3 id=触发机制-1><strong>触发机制</strong></h3><ol><li><p><strong>日志写入时机</strong></p><ul><li><p>根据配置，Redis 会将写命令同步到 AOF 文件，主要有以下模式：</p><p>bash</p><p>复制代码</p><p><code>appendfsync always # 每次写操作都立即同步到磁盘，性能低但最安全 appendfsync everysec # 每秒同步一次，性能与安全性平衡 appendfsync no # 由操作系统决定何时同步，性能最高但风险最大</code></p></li></ul></li><li><p><strong>文件重写（Rewrite）</strong></p><ul><li>随着 AOF 文件的不断增长，文件可能会变得非常大。Redis 提供了 AOF 重写机制：<ul><li>通过合并日志命令生成更小的 AOF 文件。</li><li>使用 <code>BGREWRITEAOF</code> 命令手动触发重写。</li></ul></li></ul></li></ol><h3 id=优点-1><strong>优点</strong></h3><ul><li><strong>数据持久性更高</strong>：AOF 可以记录每一次写操作，支持 &ldquo;每秒同步&rdquo; 和 &ldquo;实时同步&rdquo; 模式，丢失数据量较少。</li><li>AOF 文件是追加的，写入性能较优。</li><li>文件可读性强（文本格式），方便调试和修复。</li></ul><h3 id=缺点-1><strong>缺点</strong></h3><ul><li>AOF 文件通常比 RDB 文件大，恢复速度较慢。</li><li>写入性能可能受磁盘 IO 的影响。</li><li>文件重写过程可能会增加系统负载。</li></ul><hr><h2 id=3-混合持久化><strong>3. 混合持久化</strong></h2><h3 id=原理-2><strong>原理</strong></h3><ul><li>从 Redis 4.0 开始，支持 RDB 和 AOF 的混合持久化。</li><li>在混合模式下，Redis 会在重写 AOF 文件时，将内存快照以 RDB 格式写入文件开头，后续的增量数据以 AOF 格式追加。</li><li>这样既兼顾了 RDB 快速恢复的优点，又保留了 AOF 的高持久性。</li></ul><h3 id=优点-2><strong>优点</strong></h3><ul><li><strong>恢复速度更快</strong>：RDB 部分快速加载，减少了纯 AOF 文件的重放时间。</li><li><strong>数据丢失风险低</strong>：结合了 AOF 的增量日志特性。</li></ul><h3 id=缺点-2><strong>缺点</strong></h3><ul><li>需要更多的存储空间，且增加了一定的实现复杂性。</li></ul><hr><h2 id=4-持久化方式的选择><strong>4. 持久化方式的选择</strong></h2><table><thead><tr><th><strong>需求场景</strong></th><th><strong>推荐持久化方式</strong></th></tr></thead><tbody><tr><td>数据持久性要求较低，性能优先</td><td>RDB</td></tr><tr><td>数据持久性要求高</td><td>AOF (<code>appendfsync everysec</code>)</td></tr><tr><td>恢复速度快且数据可靠性高</td><td>混合持久化（RDB + AOF）</td></tr><tr><td>临时性数据或完全依赖缓存</td><td>不开启持久化（关闭 RDB 和 AOF）</td></tr></tbody></table><p>Redis 的过期删除策略用于管理过期键（即设置了有效期的键），确保 Redis 内存中的数据不会因为过期而占用不必要的空间。Redis 提供了几种删除过期键的策略，以及与内存管理和过期删除相关的机制。</p><h3 id=1-redis-过期键管理机制><strong>1. Redis 过期键管理机制</strong></h3><p>Redis 中的键过期是通过设置 <strong>过期时间（TTL）</strong> 来实现的。每个键都可以设置一个生存时间（TTL），当这个时间到达后，Redis 会将这个键标记为过期键。Redis 提供了多种方式来删除这些过期键：</p><ol><li><strong>惰性删除（Lazy deletion）</strong></li><li><strong>定期删除（Active deletion）</strong></li><li><strong>组合删除策略（惰性删除 + 定期删除）</strong></li></ol><p>这些策略的实现确保 Redis 能够以不同的方式删除过期数据，从而在性能和资源管理上取得平衡。</p><hr><h2 id=2-删除策略详解><strong>2. 删除策略详解</strong></h2><h3 id=21-惰性删除lazy-deletion><strong>2.1 惰性删除（Lazy Deletion）</strong></h3><ul><li><strong>原理：</strong> 惰性删除的策略是，Redis 仅在访问某个键时，检查它是否已过期。如果键已经过期，则会删除该键并返回一个空值。</li><li><strong>触发时机：</strong> 每次客户端访问一个键时，Redis 会检查该键是否已经过期，如果过期，则删除该键。</li><li><strong>特点：</strong><ul><li><strong>优点：</strong> 不会消耗额外的 CPU 资源进行过期键检查，操作简单、低开销。</li><li><strong>缺点：</strong> 如果过期键没有被访问，那么它就一直占用内存直到 Redis 自动执行定期删除。</li></ul></li></ul><h3 id=22-定期删除active-deletion><strong>2.2 定期删除（Active Deletion）</strong></h3><ul><li><strong>原理：</strong> Redis 会定期进行检查，遍历一定数量的过期键并将它们删除。这是通过一个定时任务实现的，通常 Redis 会每隔一定时间（默认 100 毫秒）扫描一次。</li><li><strong>触发时机：</strong> Redis 会每隔一段时间（默认每 100 毫秒）扫描部分过期键并删除。</li><li><strong>特点：</strong><ul><li><strong>优点：</strong> 可以主动清理过期键，避免因过期键占用内存导致的内存泄漏。</li><li><strong>缺点：</strong> 定期删除的过程中 Redis 可能会有短暂的性能波动，因为它需要遍历和删除过期键。</li></ul></li></ul><h3 id=23-组合删除策略惰性删除--定期删除><strong>2.3 组合删除策略（惰性删除 + 定期删除）</strong></h3><ul><li>Redis 使用 <strong>惰性删除</strong> 和 <strong>定期删除</strong> 结合的方式来管理过期键。具体机制如下：<ul><li><strong>惰性删除：</strong> 当客户端访问某个键时，Redis 会检查该键是否过期，并且如果已过期就删除它。</li><li><strong>定期删除：</strong> Redis 会每 100 毫秒检查和删除部分过期键，确保即使某些过期键没有被访问，也能被删除。</li></ul></li></ul><p>这种策略的设计目的是平衡性能和内存管理，避免过期键占用不必要的内存，同时避免在访问过期键时带来不必要的性能消耗。</p><hr><h2 id=3-过期键删除策略的配置><strong>3. 过期键删除策略的配置</strong></h2><p>Redis 允许对过期删除策略进行一定程度的配置：</p><h3 id=31-定期删除的相关参数><strong>3.1 定期删除的相关参数</strong></h3><ol><li><p><strong><code>hz</code>（Redis 频率设置）</strong></p><ul><li>Redis 定期扫描过期键的频率由 <code>hz</code> 参数控制。默认值为 10，意味着 Redis 每秒执行 10 次周期性的过期键检查。该值越高，过期键清理越频繁，但会增加 CPU 使用。</li><li>可以通过 <code>redis.conf</code> 文件或启动参数进行调整：<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>hz <span style=color:#ae81ff>10</span>   <span style=color:#75715e># 默认 10，表示每秒检查 10 次</span>
</span></span></code></pre></div></li></ul></li><li><p><strong><code>active-expire-effort</code></strong></p><ul><li>Redis 执行过期删除的工作量（即检查过期键的数量）由 <code>active-expire-effort</code> 参数控制。该值越高，Redis 每次检查过期键的数量越多，从而减少执行多次检查的次数，但会导致性能消耗增大。</li><li>该参数的默认值为 1，通常不需要手动修改，除非 Redis 实例有特别高的过期键处理需求。</li></ul></li></ol><h3 id=32-内存限制><strong>3.2 内存限制</strong></h3><ul><li>Redis 支持设置内存限制，当内存达到某个阈值时，Redis 会通过 <strong>LRU（最近最少使用）</strong> 或 <strong>LFU（最不常用）</strong> 算法删除键来腾出空间。如果设置了内存限制，并且存在过期的键，Redis 会优先删除过期键，而不是删除其他键。</li></ul><p>可以通过以下配置设置 Redis 的最大内存：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>maxmemory 100mb   <span style=color:#75715e># 限制 Redis 最大内存为 100MB</span>
</span></span></code></pre></div><p>同时，还可以指定 Redis 在内存限制达到时如何处理键：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>maxmemory-policy noeviction   <span style=color:#75715e># 超过内存限制时不进行任何驱逐</span>
</span></span><span style=display:flex><span>maxmemory-policy allkeys-lru <span style=color:#75715e># 使用 LRU 算法从所有键中驱逐</span>
</span></span><span style=display:flex><span>maxmemory-policy volatile-lru <span style=color:#75715e># 仅从有过期时间的键中使用 LRU 算法驱逐</span>
</span></span></code></pre></div><hr><h2 id=4-常见过期删除配置><strong>4. 常见过期删除配置</strong></h2><p>Redis 默认使用惰性删除与定期删除相结合的方式，通常情况下无需修改默认配置。但如果需要调整策略，可以通过以下配置来优化性能：</p><ol><li><p><strong>启用/禁用过期键删除</strong></p><ul><li>Redis 允许通过配置关闭或启用过期键的删除（不推荐关闭过期删除）：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>stop-writes-on-bgsave-error no   <span style=color:#75715e># 当 RDB 快照保存失败时，不停止写入（影响过期删除）</span>
</span></span></code></pre></div></li><li><p><strong>控制过期删除的时间范围</strong></p><ul><li>默认情况下，Redis 会每 100 毫秒检查过期键的删除，可以通过调整以下配置控制：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>active-expire-effort <span style=color:#ae81ff>1</span>  <span style=color:#75715e># 设置每次扫描的工作量</span>
</span></span></code></pre></div></li></ol><hr><h2 id=5-总结-1><strong>5. 总结</strong></h2><p>Redis 提供了以下三种过期键删除策略：</p><ol><li><strong>惰性删除（Lazy deletion）</strong>：只有在访问键时，才会检查并删除过期键。</li><li><strong>定期删除（Active deletion）</strong>：定期扫描部分过期键并删除。</li><li><strong>组合策略（惰性删除 + 定期删除）</strong>：Redis 默认使用该策略，即结合了惰性删除和定期删除。</li></ol><p>Redis 会每隔一定时间（默认 100 毫秒）扫描并删除过期键，同时也会在访问过期键时进行删除。通过调整 <code>hz</code> 和 <code>active-expire-effort</code> 等配置，可以优化过期键的删除策略，以平衡性能和内存管理。</p><p>在 Go 语言中实现玩家积分排序的 <strong>Top N</strong> 算法，我们可以通过多种方式来实现。这里将介绍几种常见的方法，包括使用 <strong>最小堆</strong>（Min-Heap）、<strong>排序</strong>、和 <strong>快速选择</strong>（QuickSelect）算法。</p><h3 id=1-使用最小堆min-heap><strong>1. 使用最小堆（Min-Heap）</strong></h3><p>最小堆是一种非常高效的解决方案，特别适合当玩家总数非常大，而 <code>Top N</code> 比较小的情况。最小堆保证了堆顶元素始终是最小的，因此可以在不完全排序的情况下快速找出 Top N 元素。</p><h3 id=思路><strong>思路：</strong></h3><ul><li>使用 Go 的 <code>heap</code> 包来实现最小堆。</li><li>遍历所有玩家，如果堆的大小小于 <code>N</code>，则直接加入堆中。</li><li>如果堆已满，且当前玩家的积分大于堆顶元素（最小元素），则替换堆顶元素。</li></ul><h3 id=go-代码实现><strong>Go 代码实现：</strong></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;container/heap&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Player 表示一个玩家的结构体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Player</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ID</span>    <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Score</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// MinHeap 定义一个最小堆结构体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MinHeap</span> []<span style=color:#a6e22e>Player</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 实现 heap.Interface 接口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#a6e22e>MinHeap</span>) <span style=color:#a6e22e>Len</span>() <span style=color:#66d9ef>int</span>           { <span style=color:#66d9ef>return</span> len(<span style=color:#a6e22e>h</span>) }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#a6e22e>MinHeap</span>) <span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>h</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Score</span> &lt; <span style=color:#a6e22e>h</span>[<span style=color:#a6e22e>j</span>].<span style=color:#a6e22e>Score</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#a6e22e>MinHeap</span>) <span style=color:#a6e22e>Swap</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>)      { <span style=color:#a6e22e>h</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>h</span>[<span style=color:#a6e22e>j</span>] = <span style=color:#a6e22e>h</span>[<span style=color:#a6e22e>j</span>], <span style=color:#a6e22e>h</span>[<span style=color:#a6e22e>i</span>] }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Push 方法将一个元素推入堆中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MinHeap</span>) <span style=color:#a6e22e>Push</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>interface</span>{}) {
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span><span style=color:#a6e22e>h</span> = append(<span style=color:#f92672>*</span><span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>x</span>.(<span style=color:#a6e22e>Player</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Pop 方法从堆中弹出一个最小元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MinHeap</span>) <span style=color:#a6e22e>Pop</span>() <span style=color:#66d9ef>interface</span>{} {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>old</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>h</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>old</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>old</span>[<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span><span style=color:#a6e22e>h</span> = <span style=color:#a6e22e>old</span>[<span style=color:#ae81ff>0</span> : <span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// TopNPlayers 获取前 N 个积分最高的玩家
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TopNPlayers</span>(<span style=color:#a6e22e>players</span> []<span style=color:#a6e22e>Player</span>, <span style=color:#a6e22e>N</span> <span style=color:#66d9ef>int</span>) []<span style=color:#a6e22e>Player</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 创建一个最小堆
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>h</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>MinHeap</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>heap</span>.<span style=color:#a6e22e>Init</span>(<span style=color:#a6e22e>h</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 遍历玩家列表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>player</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>players</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 如果堆还没有达到 N 大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>Len</span>() &lt; <span style=color:#a6e22e>N</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>heap</span>.<span style=color:#a6e22e>Push</span>(<span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>player</span>)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 如果堆已满且当前玩家积分大于堆顶的最小值，则替换堆顶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>player</span>.<span style=color:#a6e22e>Score</span> &gt; (<span style=color:#f92672>*</span><span style=color:#a6e22e>h</span>)[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>Score</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>heap</span>.<span style=color:#a6e22e>Pop</span>(<span style=color:#a6e22e>h</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>heap</span>.<span style=color:#a6e22e>Push</span>(<span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>player</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 将堆中的玩家按积分从高到低排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>result</span> []<span style=color:#a6e22e>Player</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>Len</span>() &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>result</span> = append(<span style=color:#a6e22e>result</span>, <span style=color:#a6e22e>heap</span>.<span style=color:#a6e22e>Pop</span>(<span style=color:#a6e22e>h</span>).(<span style=color:#a6e22e>Player</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 反转结果，确保按积分从高到低排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>, len(<span style=color:#a6e22e>result</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>j</span>; <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> = <span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>j</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>result</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>result</span>[<span style=color:#a6e22e>j</span>] = <span style=color:#a6e22e>result</span>[<span style=color:#a6e22e>j</span>], <span style=color:#a6e22e>result</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>players</span> <span style=color:#f92672>:=</span> []<span style=color:#a6e22e>Player</span>{
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>Score</span>: <span style=color:#ae81ff>100</span>},
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>Score</span>: <span style=color:#ae81ff>200</span>},
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>3</span>, <span style=color:#a6e22e>Score</span>: <span style=color:#ae81ff>150</span>},
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>4</span>, <span style=color:#a6e22e>Score</span>: <span style=color:#ae81ff>50</span>},
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>5</span>, <span style=color:#a6e22e>Score</span>: <span style=color:#ae81ff>120</span>},
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 获取前 3 名玩家
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>topPlayers</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>TopNPlayers</span>(<span style=color:#a6e22e>players</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>player</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>topPlayers</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Player ID: %d, Score: %d\n&#34;</span>, <span style=color:#a6e22e>player</span>.<span style=color:#a6e22e>ID</span>, <span style=color:#a6e22e>player</span>.<span style=color:#a6e22e>Score</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=解释><strong>解释：</strong></h3><ol><li><strong>Player 结构体</strong>：用于表示一个玩家，包括玩家 ID 和积分。</li><li><strong>MinHeap 结构体</strong>：实现了 Go 标准库 <code>heap.Interface</code> 接口，能够支持最小堆操作。<code>Len</code>、<code>Less</code>、<code>Swap</code>、<code>Push</code> 和 <code>Pop</code> 方法是 <code>heap.Interface</code> 的要求。</li><li><strong>TopNPlayers 函数</strong>：<ul><li>使用最小堆维护前 <code>N</code> 个最高积分的玩家。</li><li>遍历玩家列表，如果堆的大小小于 <code>N</code>，就将玩家加入堆；如果堆已经满了，且当前玩家积分大于堆顶元素，则替换堆顶。</li><li>最后将堆中的元素按积分从高到低排序，返回前 <code>N</code> 名玩家。</li></ul></li></ol><h3 id=时间复杂度><strong>时间复杂度：</strong></h3><ul><li>插入操作 <code>heap.Push</code> 和弹出操作 <code>heap.Pop</code> 的时间复杂度为 <strong>O(log N)</strong>，因此遍历 <code>K</code> 个玩家的总时间复杂度为 <strong>O(K log N)</strong>。</li></ul><hr><h2 id=2-使用排序sorting><strong>2. 使用排序（Sorting）</strong></h2><p>如果数据量不是特别大，且排序操作可以接受，可以直接通过 Go 的内置排序功能对玩家进行排序，之后取前 <code>N</code> 个玩家。</p><h3 id=go-代码实现-1><strong>Go 代码实现：</strong></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;sort&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Player 结构体定义
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Player</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ID</span>    <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Score</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 按积分从高到低排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TopNPlayers</span>(<span style=color:#a6e22e>players</span> []<span style=color:#a6e22e>Player</span>, <span style=color:#a6e22e>N</span> <span style=color:#66d9ef>int</span>) []<span style=color:#a6e22e>Player</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 使用 sort.Sort 对玩家按积分排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Slice</span>(<span style=color:#a6e22e>players</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>players</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Score</span> &gt; <span style=color:#a6e22e>players</span>[<span style=color:#a6e22e>j</span>].<span style=color:#a6e22e>Score</span>
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 返回前 N 个玩家
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>N</span> &gt; len(<span style=color:#a6e22e>players</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>N</span> = len(<span style=color:#a6e22e>players</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>players</span>[:<span style=color:#a6e22e>N</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>players</span> <span style=color:#f92672>:=</span> []<span style=color:#a6e22e>Player</span>{
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>Score</span>: <span style=color:#ae81ff>100</span>},
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>Score</span>: <span style=color:#ae81ff>200</span>},
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>3</span>, <span style=color:#a6e22e>Score</span>: <span style=color:#ae81ff>150</span>},
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>4</span>, <span style=color:#a6e22e>Score</span>: <span style=color:#ae81ff>50</span>},
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>5</span>, <span style=color:#a6e22e>Score</span>: <span style=color:#ae81ff>120</span>},
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 获取前 3 名玩家
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>topPlayers</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>TopNPlayers</span>(<span style=color:#a6e22e>players</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>player</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>topPlayers</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Player ID: %d, Score: %d\n&#34;</span>, <span style=color:#a6e22e>player</span>.<span style=color:#a6e22e>ID</span>, <span style=color:#a6e22e>player</span>.<span style=color:#a6e22e>Score</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=解释-1><strong>解释：</strong></h3><ul><li>使用 <code>sort.Slice</code> 按照玩家积分从高到低进行排序。</li><li>最后返回排序后的前 <code>N</code> 个玩家。</li></ul><h3 id=时间复杂度-1><strong>时间复杂度：</strong></h3><ul><li>排序的时间复杂度是 <strong>O(K log K)</strong>，其中 <code>K</code> 是玩家总数。</li></ul><hr><h2 id=3-使用快速选择quickselect><strong>3. 使用快速选择（QuickSelect）</strong></h2><p><code>QuickSelect</code> 是一种基于快速排序的算法，可以用来在不完全排序的情况下找到第 <code>N</code> 大的元素。它比完全排序更高效，适合大规模数据。</p><h3 id=go-代码实现-2><strong>Go 代码实现：</strong></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;math/rand&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Player 结构体定义
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Player</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ID</span>    <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Score</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 快速选择算法：用于找到第 N 大的元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>quickSelect</span>(<span style=color:#a6e22e>players</span> []<span style=color:#a6e22e>Player</span>, <span style=color:#a6e22e>left</span>, <span style=color:#a6e22e>right</span>, <span style=color:#a6e22e>N</span> <span style=color:#66d9ef>int</span>) []<span style=color:#a6e22e>Player</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>right</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>players</span>[:<span style=color:#a6e22e>N</span>]
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 随机选择一个枢轴
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>pivotIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#a6e22e>right</span><span style=color:#f92672>-</span><span style=color:#a6e22e>left</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>left</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pivotIndex</span> = <span style=color:#a6e22e>partition</span>(<span style=color:#a6e22e>players</span>, <span style=color:#a6e22e>left</span>, <span style=color:#a6e22e>right</span>, <span style=color:#a6e22e>pivotIndex</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>N</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>pivotIndex</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>players</span>[:<span style=color:#a6e22e>N</span>]
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>N</span> &lt; <span style=color:#a6e22e>pivotIndex</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>quickSelect</span>(<span style=color:#a6e22e>players</span>, <span style=color:#a6e22e>left</span>, <span style=color:#a6e22e>pivotIndex</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>N</span>)
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>quickSelect</span>(<span style=color:#a6e22e>players</span>, <span style=color:#a6e22e>pivotIndex</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>right</span>, <span style=color:#a6e22e>N</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 分区函数：按照分区值对数组进行分区
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>partition</span>(<span style=color:#a6e22e>players</span> []<span style=color:#a6e22e>Player</span>, <span style=color:#a6e22e>left</span>, <span style=color:#a6e22e>right</span>, <span style=color:#a6e22e>pivotIndex</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pivotValue</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>players</span>[<span style=color:#a6e22e>pivotIndex</span>].<span style=color:#a6e22e>Score</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>players</span>[<span style=color:#a6e22e>pivotIndex</span>], <span style=color:#a6e22e>players</span>[<span style=color:#a6e22e>right</span>] = <span style=color:#a6e22e>players</span>[<span style=color:#a6e22e>right</span>], <span style=color:#a6e22e>players</span>[<span style=color:#a6e22e>pivotIndex</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>storeIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>left</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>left</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>right</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>players</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Score</span> &gt; <span style=color:#a6e22e>pivotValue</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>players</span>[<span style=color:#a6e22e>storeIndex</span>], <span style=color:#a6e22e>players</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>players</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>players</span>[<span style=color:#a6e22e>storeIndex</span>]
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>storeIndex</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>players</span>[<span style=color:#a6e22e>right</span>], <span style=color:#a6e22e>players</span>[<span style=color:#a6e22e>storeIndex</span>] = <span style=color:#a6e22e>players</span>[<span style=color:#a6e22e>storeIndex</span>], <span style=color:#a6e22e>players</span>[<span style=color:#a6e22e>right</span>]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>storeIndex</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// TopNPlayers 使用快速选择算法获取前 N 个玩家
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TopNPlayers</span>(<span style=color:#a6e22e>players</span> []<span style=color:#a6e22e>Player</span>, <span style=color:#a6e22e>N</span> <span style=color:#66d9ef>int</span>) []<span style=color:#a6e22e>Player</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>quickSelect</span>(<span style=color:#a6e22e>players</span>, <span style=color:#ae81ff>0</span>, len(<span style=color:#a6e22e>players</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>N</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>players</span> <span style=color:#f92672>:=</span> []<span style=color:#a6e22e>Player</span>{
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>Score</span>: <span style=color:#ae81ff>100</span>},
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>Score</span>: <span style=color:#ae81ff>200</span>},
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>3</span>, <span style=color:#a6e22e>Score</span>: <span style=color:#ae81ff>150</span>},
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>4</span>, <span style=color:#a6e22e>Score</span>: <span style=color:#ae81ff>50</span>},
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>5</span>, <span style=color:#a6e22e>Score</span>: <span style=color:#ae81ff>120</span>},
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 获取前 3 名玩家
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>topPlayers</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>TopNPlayers</span>(<span style=color:#a6e22e>players</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>player</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>topPlayers</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Player ID: %d, Score: %d\n&#34;</span>, <span style=color:#a6e22e>player</span>.<span style=color:#a6e22e>ID</span>, <span style=color:#a6e22e>player</span>.<span style=color:#a6e22e>Score</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=解释-2><strong>解释：</strong></h3><ul><li><code>quickSelect</code> 使用快速选择算法找到第 <code>N</code> 大的玩家</li></ul><p>，并返回前 <code>N</code> 名玩家。</p><ul><li><code>partition</code> 函数用于将玩家按积分进行分区。</li><li>时间复杂度为 <strong>O(K)</strong>（平均情况下），但最坏情况下是 <strong>O(K²)</strong>。</li></ul><hr><h2 id=总结-3><strong>总结</strong></h2><ul><li><strong>最小堆（Min-Heap）</strong>：适用于玩家数较多而 <code>N</code> 较小的情况，时间复杂度为 <strong>O(K log N)</strong>。</li><li><strong>排序（Sorting）</strong>：简单直接，适用于数据量不大，时间复杂度为 <strong>O(K log K)</strong>。</li><li><strong>快速选择（QuickSelect）</strong>：适用于大数据量，且需要高效地找到 Top N 的场景，平均时间复杂度为 <strong>O(K)</strong>。</li></ul><h2 id=七little-endian-和-big-endian><strong>七、Little endian 和 Big endian</strong></h2><p>上一节已经提到，UCS-2 格式可以存储 Unicode 码（码点不超过<code>0xFFFF</code>）。以汉字<code>严</code>为例，Unicode 码是<code>4E25</code>，需要用两个字节存储，一个字节是<code>4E</code>，另一个字节是<code>25</code>。存储的时候，<code>4E</code>在前，<code>25</code>在后，这就是 Big endian 方式；<code>25</code>在前，<code>4E</code>在后，这是 Little endian 方式。
Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做"零宽度非换行空格"（zero width no-break space），用<code>FEFF</code>表示。这正好是两个字节，而且<code>FF</code>比<code>FE</code>大<code>1</code>。</p><p>如果一个文本文件的头两个字节是<code>FE FF</code>，就表示该文件采用大头方式；如果头两个字节是<code>FF FE</code>，就表示该文件采用小头方式。</p><p>Redis 提供了多种数据结构，每种数据结构都适用于不同的应用场景。以下是 Redis 中的常用数据结构及其主要用途：</p><hr><h2 id=1-string字符串><strong>1. String（字符串）</strong></h2><p><strong>概述</strong>：</p><ul><li>Redis 中最基础的数据结构，存储一个键对应的单个字符串值。</li><li>可以存储字符串、整数、浮点数等类型的数据。</li></ul><p><strong>操作</strong>：</p><ul><li><code>SET key value</code>：设置键的值。</li><li><code>GET key</code>：获取键的值。</li><li><code>INCR key</code>、<code>DECR key</code>：对键的值自增、自减（数值类型）。</li><li><code>APPEND key value</code>：将值追加到已有的值后面。</li></ul><p><strong>应用场景</strong>：</p><ul><li>缓存常规字符串数据，例如用户信息、配置数据。</li><li>计数器，例如访问量统计。</li><li>分布式锁（通过 <code>SETNX</code> 实现）。</li></ul><hr><h2 id=2-hash哈希><strong>2. Hash（哈希）</strong></h2><p><strong>概述</strong>：</p><ul><li>存储键值对集合，类似于 Python 中的字典。</li><li>适合存储对象或结构化数据。</li></ul><p><strong>操作</strong>：</p><ul><li><code>HSET key field value</code>：设置哈希表的字段值。</li><li><code>HGET key field</code>：获取哈希表中指定字段的值。</li><li><code>HDEL key field</code>：删除哈希表中的字段。</li><li><code>HGETALL key</code>：获取哈希表中的所有字段和值。</li></ul><p><strong>应用场景</strong>：</p><ul><li>存储用户对象信息，例如：<code>user:1001 -> {name: "Alice", age: 25}</code>。</li><li>数据结构化存储，例如配置表。</li></ul><hr><h2 id=3-list列表><strong>3. List（列表）</strong></h2><p><strong>概述</strong>：</p><ul><li>有序列表，支持从两端进行插入、弹出操作。</li><li>本质上是一个双向链表。</li></ul><p><strong>操作</strong>：</p><ul><li><code>LPUSH key value</code>、<code>RPUSH key value</code>：从左侧或右侧插入元素。</li><li><code>LPOP key</code>、<code>RPOP key</code>：从左侧或右侧弹出元素。</li><li><code>LRANGE key start stop</code>：获取指定范围内的元素。</li></ul><p><strong>应用场景</strong>：</p><ul><li>消息队列（结合阻塞操作 <code>BLPOP</code> 或 <code>BRPOP</code> 实现）。</li><li>任务列表或日志记录。</li><li>实现简单的栈或队列。</li></ul><hr><h2 id=4-set集合><strong>4. Set（集合）</strong></h2><p><strong>概述</strong>：</p><ul><li>无序集合，元素不重复。</li><li>提供集合运算，如交集、并集、差集等。</li></ul><p><strong>操作</strong>：</p><ul><li><code>SADD key value</code>：向集合中添加元素。</li><li><code>SREM key value</code>：移除集合中的元素。</li><li><code>SMEMBERS key</code>：获取集合中的所有元素。</li><li><code>SINTER key1 key2</code>：获取两个集合的交集。</li></ul><p><strong>应用场景</strong>：</p><ul><li>标签系统：例如记录一个用户的兴趣标签。</li><li>共同好友、相似用户等的集合运算。</li><li>防止重复，例如记录用户的签到或活动参与。</li></ul><hr><h2 id=5-sorted-set有序集合><strong>5. Sorted Set（有序集合）</strong></h2><p><strong>概述</strong>：</p><ul><li>类似于 Set，但每个元素关联一个分值（score），按分值排序。</li><li>底层由跳表实现，支持高效的范围查询。</li></ul><p><strong>操作</strong>：</p><ul><li><code>ZADD key score value</code>：向有序集合中添加元素及其分值。</li><li><code>ZRANGE key start stop [WITHSCORES]</code>：按分值排序后，获取指定范围内的元素。</li><li><code>ZREVRANGE key start stop</code>：按分值降序排序后，获取范围内的元素。</li><li><code>ZREM key value</code>：移除指定的元素。</li><li><code>ZRANK key value</code>：获取元素的排名（从低到高）。</li><li><code>ZCOUNT key min max</code>：统计分值在指定范围内的元素数量。</li></ul><p><strong>应用场景</strong>：</p><ul><li>排行榜，例如积分排行榜、热度排行榜。</li><li>延时队列：利用分值作为时间戳处理延时任务。</li><li>数据统计和排序，例如文章点赞数排名。</li></ul><hr><h2 id=6-bitmap位图><strong>6. Bitmap（位图）</strong></h2><p><strong>概述</strong>：</p><ul><li>用二进制位表示数据，可以实现大规模数据的状态存储。</li><li>基于 String 实现，但提供了按位操作的命令。</li></ul><p><strong>操作</strong>：</p><ul><li><code>SETBIT key offset value</code>：设置指定偏移量的位值。</li><li><code>GETBIT key offset</code>：获取指定偏移量的位值。</li><li><code>BITCOUNT key [start end]</code>：统计位值为 1 的数量。</li><li><code>BITOP op destkey key1 key2</code>：对多个 Bitmap 执行按位操作（AND、OR、XOR）。</li></ul><p><strong>应用场景</strong>：</p><ul><li>用户签到（每天一个二进制位，1 表示签到，0 表示未签到）。</li><li>大量布尔值的状态存储，例如黑名单或在线状态。</li><li>唯一访客统计（结合布隆过滤器）。</li></ul><hr><h2 id=7-hyperloglog><strong>7. HyperLogLog</strong></h2><p><strong>概述</strong>：</p><ul><li>一种基数估算数据结构，用于快速计算集合的基数（去重后的元素数量）。</li><li>占用内存固定，约 12 KB，但结果不完全精确，误差约为 0.81%。</li></ul><p><strong>操作</strong>：</p><ul><li><code>PFADD key element</code>：向 HyperLogLog 添加元素。</li><li><code>PFCOUNT key</code>：获取基数估算值。</li><li><code>PFMERGE destkey key1 key2</code>：合并多个 HyperLogLog。</li></ul><p><strong>应用场景</strong>：</p><ul><li>统计网站的 UV（独立访客数）。</li><li>去重统计，例如统计某商品的购买用户数量。</li></ul><hr><h2 id=8-stream流><strong>8. Stream（流）</strong></h2><p><strong>概述</strong>：</p><ul><li>Redis 的消息队列数据结构，类似于 Kafka 或 RabbitMQ。</li><li>可以存储时间序列数据，支持消费组（Consumer Group）。</li></ul><p><strong>操作</strong>：</p><ul><li><code>XADD key ID field value</code>：向流中添加消息。</li><li><code>XRANGE key start end</code>：按 ID 范围获取消息。</li><li><code>XREAD COUNT count STREAMS key id</code>：读取消息。</li><li><code>XGROUP CREATE key groupname id</code>：创建消费组。</li><li><code>XREADGROUP GROUP groupname consumer STREAMS key id</code>：从消费组中读取消息。</li></ul><p><strong>应用场景</strong>：</p><ul><li>消息队列或日志系统。</li><li>数据流处理，例如实时监控或事件处理。</li></ul><hr><h2 id=总结与对比><strong>总结与对比</strong></h2><table><thead><tr><th>数据结构</th><th>特点和用途</th><th>典型应用场景</th></tr></thead><tbody><tr><td><strong>String</strong></td><td>简单、灵活，适用于存储任意值</td><td>缓存数据、计数器、分布式锁</td></tr><tr><td><strong>Hash</strong></td><td>适合存储结构化数据</td><td>存储用户对象、配置数据</td></tr><tr><td><strong>List</strong></td><td>有序、支持队列和栈操作</td><td>消息队列、任务列表</td></tr><tr><td><strong>Set</strong></td><td>无序、不重复，支持集合运算</td><td>标签系统、唯一标识管理</td></tr><tr><td><strong>Sorted Set</strong></td><td>有序集合，按分值排序</td><td>排行榜、延时队列、数据统计</td></tr><tr><td><strong>Bitmap</strong></td><td>用位操作存储和计算状态数据</td><td>签到系统、大规模状态存储</td></tr><tr><td><strong>HyperLogLog</strong></td><td>基数估算</td><td>去重统计、大规模数据的快速统计</td></tr><tr><td><strong>Stream</strong></td><td>日志和消息队列功能</td><td>实时消息系统、事件处理</td></tr></tbody></table><p>根据具体需求选择合适的数据结构，可以充分发挥 Redis 的高性能特性。</p><h3 id=1-struct-可比较的条件><strong>1. Struct 可比较的条件</strong></h3><ul><li>Go 中的 struct 可以用 <code>==</code> 或 <code>!=</code> 进行比较，前提是：<ul><li><strong>所有字段都是可比较的</strong>。</li><li>可比较的类型包括：<ul><li>基本类型（如 <code>int</code>、<code>float</code>、<code>string</code> 等）。</li><li>指针类型。</li><li>可以直接比较的数组（数组元素类型也必须可比较）。</li></ul></li></ul></li></ul><p>如果 struct 中包含不可比较的字段（如切片 <code>slice</code>、映射 <code>map</code>、函数 <code>func</code> 等），那么整个 struct 是 <strong>不可比较的</strong>，编译时会报错。</p><p>在 Go 中，<code>context</code> 包用于 <strong>上下文管理</strong>，它主要解决以下问题：</p><ol><li><strong>协程间的取消信号传递</strong>：通过 <code>context</code>，可以向多个协程发送取消信号，优雅地停止协程。</li><li><strong>设置超时或截止时间</strong>：可以为函数调用链设置超时时间，超时后自动取消操作。</li><li><strong>传递元数据</strong>：允许在函数调用链中传递一些轻量级的上下文数据。</li></ol><p><code>context</code> 包常用于处理需要控制超时、取消或者传递元数据的并发任务，尤其是在 HTTP 服务、RPC 调用、数据库访问等场景中。</p><h3 id=client如何实现长链接>client如何实现长链接</h3><ul><li><strong>HTTP 长连接</strong>：通过设置 <code>KeepAlive</code>。</li><li><strong>WebSocket</strong>：用于全双工通信的长连接。</li><li><strong>TCP 长连接</strong>：适用于自定义协议和高效通信。</li><li><strong>gRPC</strong>：基于 HTTP/2，天然支持长连接和多路复用。</li><li>实现长连接时，需要注意连接的保活、断开重连和资源管理。</li></ul><h3 id=go-中-slice-的核心概念><strong>Go 中 Slice 的核心概念</strong></h3><p>Go 的 <code>slice</code> 是一种 <strong>动态数组</strong>，提供了灵活且高效的数组操作。它的本质是一个三元组结构：</p><ul><li><strong>指向底层数组的指针</strong>。</li><li><strong>长度（len）</strong>：当前切片的元素数量。</li><li><strong>容量（cap）</strong>：从切片起始位置到底层数组末尾的最大元素数。</li></ul><p>以下是对 <code>slice</code> 的 <code>len</code>、<code>cap</code>、共享底层数组以及扩容机制的详细讲解。</p><ul><li><strong><code>len(slice)</code></strong>：返回切片中当前的元素数量。</li><li><strong><code>cap(slice)</code></strong>：返回从切片起始位置到底层数组末尾的容量。
多个切片可以共享一个底层数组。操作一个切片可能会影响其他共享同一底层数组的切片。</li></ul><p>当向切片追加元素并且超出容量时，Go 会自动扩容。扩容时：</p><ol><li>分配一个新的底层数组。</li><li>将旧切片的内容复制到新数组。</li><li>返回新的切片。
扩容规则（大致）</li></ol><ul><li>当切片长度小于 1024，通常容量翻倍。</li><li>当长度超过 1024，容量会增加至原来的 1.25 倍。</li></ul><p>在扩容之前，切片共享底层数组；扩容之后，新切片与原底层数组分离，修改不会互相影响。</p><h3 id=3-总结稳定性分类><strong>3. 总结：稳定性分类</strong></h3><h4 id=稳定的排序算法><strong>稳定的排序算法</strong></h4><ul><li>冒泡排序（Bubble Sort）</li><li>插入排序（Insertion Sort）</li><li>归并排序（Merge Sort）</li><li>基数排序（Radix Sort）</li><li>计数排序（Counting Sort）</li></ul><h4 id=不稳定的排序算法><strong>不稳定的排序算法</strong></h4><ul><li><p>快速排序（Quick Sort）</p></li><li><p>选择排序（Selection Sort）</p></li><li><p>堆排序（Heap Sort）</p><ul><li><strong>401 Unauthorized</strong>：表示请求缺乏有效的身份验证凭证，需要提供凭证才能访问资源。</li></ul></li><li><p><strong>403 Forbidden</strong>：表示请求已被理解且验证通过，但服务器明确拒绝该请求，客户端没有权限访</p></li></ul><h3 id=raft-算法概述>Raft 算法概述</h3><p>Raft 算法的核心目标是确保分布式系统中的多个节点在面对节点故障、网络分区等问题时，仍然能够达成一致，保证系统的数据一致性。Raft 算法采用了领导者（Leader）机制，整个系统中的节点分为三种角色：<strong>领导者（Leader）</strong>、<strong>跟随者（Follower）</strong> 和 <strong>候选者（Candidate）</strong>。</p><h3 id=raft-算法的特点>Raft 算法的特点</h3><p>Raft 算法通过以下几个关键概念和机制来实现一致性：</p><ol><li><p><strong>领导者选举</strong>：</p><ul><li>Raft 使用 <strong>领导者选举</strong> 来决定哪一个节点作为主节点（Leader）。其他节点会作为 <strong>跟随者</strong>（Follower）存在。只有领导者才能处理客户端的请求。</li><li>如果领导者节点失效，系统会触发选举，选举出一个新的领导者来继续处理请求。</li></ul></li><li><p><strong>日志复制</strong>：</p><ul><li>领导者负责接收客户端请求并将日志条目（客户端的操作）复制到所有跟随者上，确保所有节点的日志一致。</li><li>每个节点都有一个日志条目，记录系统的状态变化。Raft 确保了日志的一致性，只有在领导者和大多数节点的日志一致时，才认为日志条目已提交。</li></ul></li><li><p><strong>心跳机制</strong>：</p><ul><li>领导者定期向跟随者发送 <strong>心跳</strong>，以避免跟随者将领导者误认为失效，并开始进行选举。心跳用于维持领导者的身份。</li></ul></li><li><p><strong>日志一致性</strong>：</p><ul><li>Raft 保证 <strong>日志条目的顺序一致性</strong>，即在所有节点中，提交的日志条目是顺序一致的。如果某个日志条目在某个节点提交，那么该条目在其他节点也必须在相同的索引处提交。</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li>Raft 保证 <strong>日志的一致性和顺序性</strong>，即如果某个日志条目已经被提交并且被多数节点确认，那么该条目在未来不会被覆盖或撤销。</li><li>如果一个节点的日志已经提交到系统中，它的所有日志条目会在新的领导者出现时保持一致。</li></ul></li><li><p><strong>集群成员变化</strong>：</p><ul><li>Raft 还支持动态地改变集群成员，即可以在不中断服务的情况下增加或删除节点。Raft 通过 <strong>联合共识</strong>（joint consensus）机制来处理这种变化。</li></ul></li></ol><h4 id=es>Es</h4><h4 id=mysql事务>MySQL事务</h4></section><div class=paginator><a class=next href=https://echotrue.github.io/blog/game/nano/nano-new/><span></span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://echotrue.github.io/>AXLROSE</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
Theme by
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>