<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Golang结构体中的匿名接口</title>
<meta charset=utf-8><meta name=description content="Ladder@Struct embed interface
标准库中有很多结构体中内嵌一个匿名的接口这种写法，今天我们来研究并总结下这种写法的意义。以sort包为例：
type Interface interface {
	// Len is the number of elements in the collection.
	Len() int

	// Less reports whether the element with index i
	Less(i, j int) bool

	// Swap swaps the elements with indexes i and j.
	Swap(i, j int)
}

type reverse struct {
	// This embedded Interface permits Reverse to use the methods of
	// another Interface implementation.
	Interface
}

// Less returns the opposite of the embedded implementation's Less method.
func (r reverse) Less(i, j int) bool {
	return r.Interface.Less(j, i)
}

// Reverse returns the reverse order for data.
func Reverse(data Interface) Interface {
	return &amp;reverse{data}
}
Interface接口定义了三个方法。reverse结构体内嵌了一个名为Interface的匿名的接口，并且提供了单独的Less函数定义，却没有提供Len和Swap的定义。Reverse函数接收任意一个实现了Interface接口的值作为参数,然后实例化一个reverse结构体对象，并将这个参数赋值给该对象的匿名字段Interface。这里的reverse.Less将参数i,j颠倒并传递给reverse结构体中匿名字段Interface的Less()方法。而这里的Less方法则属于Interface接口的另一个实现。因此最终输出的结果肯定是不同的。"><meta name=author content="map[email:axlrose.huang@gmail.com name:Axlrose]"><link rel=canonical href=https://echotrue.github.io/blog/golang/struct-with-embedded-anonymous-interface/><link rel=alternate type=application/rss+xml href=https://echotrue.github.io//index.xml title=AXLROSE><meta property="og:url" content="https://echotrue.github.io/blog/golang/struct-with-embedded-anonymous-interface/"><meta property="og:site_name" content="AXLROSE"><meta property="og:title" content="Golang结构体中的匿名接口"><meta property="og:description" content="Struct embed interface 标准库中有很多结构体中内嵌一个匿名的接口这种写法，今天我们来研究并总结下这种写法的意义。以sort包为例：
type Interface interface { // Len is the number of elements in the collection. Len() int // Less reports whether the element with index i Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) } type reverse struct { // This embedded Interface permits Reverse to use the methods of // another Interface implementation. Interface } // Less returns the opposite of the embedded implementation's Less method. func (r reverse) Less(i, j int) bool { return r.Interface.Less(j, i) } // Reverse returns the reverse order for data. func Reverse(data Interface) Interface { return &amp;reverse{data} } Interface接口定义了三个方法。reverse结构体内嵌了一个名为Interface的匿名的接口，并且提供了单独的Less函数定义，却没有提供Len和Swap的定义。Reverse函数接收任意一个实现了Interface接口的值作为参数,然后实例化一个reverse结构体对象，并将这个参数赋值给该对象的匿名字段Interface。这里的reverse.Less将参数i,j颠倒并传递给reverse结构体中匿名字段Interface的Less()方法。而这里的Less方法则属于Interface接口的另一个实现。因此最终输出的结果肯定是不同的。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-08-28T15:08:17+08:00"><meta property="article:modified_time" content="2024-08-28T15:08:17+08:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://echotrue.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Golang结构体中的匿名接口","item":"https://echotrue.github.io/blog/golang/struct-with-embedded-anonymous-interface/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang结构体中的匿名接口","name":"Golang结构体中的匿名接口","description":"Struct embed interface 标准库中有很多结构体中内嵌一个匿名的接口这种写法，今天我们来研究并总结下这种写法的意义。以sort包为例：\ntype Interface interface { // Len is the number of elements in the collection. Len() int // Less reports whether the element with index i Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) } type reverse struct { // This embedded Interface permits Reverse to use the methods of // another Interface implementation. Interface } // Less returns the opposite of the embedded implementation\u0026#39;s Less method. func (r reverse) Less(i, j int) bool { return r.Interface.Less(j, i) } // Reverse returns the reverse order for data. func Reverse(data Interface) Interface { return \u0026amp;reverse{data} } Interface接口定义了三个方法。reverse结构体内嵌了一个名为Interface的匿名的接口，并且提供了单独的Less函数定义，却没有提供Len和Swap的定义。Reverse函数接收任意一个实现了Interface接口的值作为参数,然后实例化一个reverse结构体对象，并将这个参数赋值给该对象的匿名字段Interface。这里的reverse.Less将参数i,j颠倒并传递给reverse结构体中匿名字段Interface的Less()方法。而这里的Less方法则属于Interface接口的另一个实现。因此最终输出的结果肯定是不同的。\n","keywords":[],"articleBody":"Struct embed interface 标准库中有很多结构体中内嵌一个匿名的接口这种写法，今天我们来研究并总结下这种写法的意义。以sort包为例：\ntype Interface interface { // Len is the number of elements in the collection. Len() int // Less reports whether the element with index i Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) } type reverse struct { // This embedded Interface permits Reverse to use the methods of // another Interface implementation. Interface } // Less returns the opposite of the embedded implementation's Less method. func (r reverse) Less(i, j int) bool { return r.Interface.Less(j, i) } // Reverse returns the reverse order for data. func Reverse(data Interface) Interface { return \u0026reverse{data} } Interface接口定义了三个方法。reverse结构体内嵌了一个名为Interface的匿名的接口，并且提供了单独的Less函数定义，却没有提供Len和Swap的定义。Reverse函数接收任意一个实现了Interface接口的值作为参数,然后实例化一个reverse结构体对象，并将这个参数赋值给该对象的匿名字段Interface。这里的reverse.Less将参数i,j颠倒并传递给reverse结构体中匿名字段Interface的Less()方法。而这里的Less方法则属于Interface接口的另一个实现。因此最终输出的结果肯定是不同的。\n通过这种方式, 结构体reverse实现了sort.Interface接口，并且可以重写其中的一些方法而不用定义其他所有的方法。那么嵌入匿名接口是如何影响结构体的呢？内嵌会将被嵌入的类型（结构体或者接口，这不重要）的所有方法提升为父类型的方法，但是会使用被嵌入的类型作为方法的接收者来调用方法。这样做的一个实际副作用是结构体实现了被嵌入的接口类型，因为根据定义，结构体拥有了接口的所有方法。\n在没有为这个接口字段赋值的情况下，尝试调用这些方法会引发恐慌，因为这个接口字段默认是nil.\nduck-typing 如果想要鸭子类型,根据类型是否存在某些方法而有选择的调用行为.你需要使用类似于标准库io.WriterTo接口工作的方式.该接口与io.ReaderFrom接口一样都是io.Writer和io.Reader类型的对象可以选择性实现的接口,主要用写入或读取另外一个源,而不需要io包自己缓冲读取的或者要写入的数据.\ntype Buffer struct { bytes.Buffer ReaderFrom // conflicts with and hides bytes.Buffer's ReaderFrom. WriterTo // conflicts with and hides bytes.Buffer's WriterTo. } rb := new(bytes.Buffer) // implements WriteTo. wb := new(Buffer) rb.WriteString(\"hello, world.\") Copy(wb, rb) if wb.String() != \"hello, world.\" { t.Errorf(\"Copy did not work properly\") } 基本要旨是你要定义一个底层的接口及其所需要的方法,这就是你传递的内容.然后你就拥有一个或多个可选的接口,你可以检查传递的类型是否满足,如果满足就可以调用该接口的方法,如果不满足则恢复默认行为.这种情况下不需要类型嵌入.\n接口的嵌入更多的是关于多态的而不是鸭子类型.举个例子,如果你要访问数据库,但是想处理标准的数据库调用和事务内调用,你可以创建一个包含了两个类型(sql.DB和sql.Tx)的共同方法的接口,如下所示:\ntype dber interface { Query(query string, args ...interface{}) (*sql.Rows, error) QueryRow(query string, args ...interface{}) *sql.Row Exec(query string, args ...interface{}) (sql.Result, error) } type DBHandle struct { dber } 现在你可以在DBHandle的匿名字段dber中存储sql.DB或者sql.Tx类型的值.任何使用DBHandle包括它自己的方法中都可以调用Query(),QueryRow()和Exec()而不需要知道他们是否在事务范围内被调用.当然了前提是必须先初始化DBHandle的dber字段的值.\n","wordCount":"1263","inLanguage":"en","datePublished":"2024-08-28T15:08:17+08:00","dateModified":"2024-08-28T15:08:17+08:00","author":{"@type":"Person","name":{"email":"axlrose.huang@gmail.com","name":"Axlrose"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://echotrue.github.io/blog/golang/struct-with-embedded-anonymous-interface/"},"publisher":{"@type":"Organization","name":"AXLROSE","logo":{"@type":"ImageObject","url":"https://echotrue.github.io/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css><link rel=stylesheet href=/css/main.min.b18e8501c4f9c51c7bc74c831f88a4705978246e383d68ba514a05459901ef6f.css integrity="sha256-sY6FAcT5xRx7x0yDH4ikcFl4JG44PWi6UUoFRZkB728=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/prism.min.ab059a12f053f9764c2b65f5e83ea3a2e77c9957e453e01e0478a8ab6b11109f.css><script src=/js/prism.min.4efeed559740892c1071317ffd1e799722e52463c486cfb182fdef01622950fc.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/blog>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/series>Series</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/book>Book</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Golang结构体中的匿名接口</h1></header><p><small>August 28, 2024&nbsp;· 1263 words&nbsp;· 3 min</small>
<small></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><ul><li><a href=#struct-embed-interface>Struct embed interface</a></li><li><a href=#duck-typing>duck-typing</a></li></ul></li></ul></nav></div><section class=blog-content><h3 id=struct-embed-interface>Struct embed interface</h3><p>标准库中有很多结构体中内嵌一个匿名的接口这种写法，今天我们来研究并总结下这种写法的意义。以sort包为例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Interface</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Len is the number of elements in the collection.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Len</span>() <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Less reports whether the element with index i
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Swap swaps the elements with indexes i and j.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Swap</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>reverse</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// This embedded Interface permits Reverse to use the methods of
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// another Interface implementation.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Interface</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Less returns the opposite of the embedded implementation&#39;s Less method.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#a6e22e>reverse</span>) <span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Interface</span>.<span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>j</span>, <span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Reverse returns the reverse order for data.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Reverse</span>(<span style=color:#a6e22e>data</span> <span style=color:#a6e22e>Interface</span>) <span style=color:#a6e22e>Interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>reverse</span>{<span style=color:#a6e22e>data</span>}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Interface</code>接口定义了三个方法。<code>reverse</code>结构体内嵌了一个名为<code>Interface</code>的匿名的接口，并且提供了单独的<code>Less</code>函数定义，却没有提供<code>Len</code>和<code>Swap</code>的定义。<code>Reverse</code>函数接收任意一个实现了<code>Interface</code>接口的值作为参数,然后实例化一个<code>reverse</code>结构体对象，并将这个参数赋值给该对象的匿名字段<code>Interface</code>。这里的<code>reverse.Less</code>将参数i,j颠倒并传递给<code>reverse</code>结构体中匿名字段<code>Interface</code>的<code>Less()</code>方法。而这里的Less方法则属于<code>Interface</code>接口的另一个实现。因此最终输出的结果肯定是不同的。</p><p>通过这种方式, 结构体<code>reverse</code>实现了<code>sort.Interface</code>接口，并且可以重写其中的一些方法而不用定义其他所有的方法。那么嵌入匿名接口是如何影响结构体的呢？内嵌会将被嵌入的类型（结构体或者接口，这不重要）的所有方法提升为父类型的方法，但是会使用被嵌入的类型作为方法的接收者来调用方法。这样做的一个实际副作用是结构体实现了被嵌入的接口类型，因为根据定义，结构体拥有了接口的所有方法。</p><blockquote><p>在没有为这个接口字段赋值的情况下，尝试调用这些方法会引发恐慌，因为这个接口字段默认是<code>nil</code>.</p></blockquote><h3 id=duck-typing>duck-typing</h3><p>如果想要鸭子类型,根据类型是否存在某些方法而有选择的调用行为.你需要使用类似于标准库<code>io.WriterTo</code>接口工作的方式.该接口与<code>io.ReaderFrom</code>接口一样都是<code>io.Writer</code>和<code>io.Reader</code>类型的对象可以选择性实现的接口,主要用写入或读取另外一个源,而不需要<code>io</code>包自己缓冲读取的或者要写入的数据.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Buffer</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>  
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ReaderFrom</span> <span style=color:#75715e>// conflicts with and hides bytes.Buffer&#39;s ReaderFrom.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>WriterTo</span>   <span style=color:#75715e>// conflicts with and hides bytes.Buffer&#39;s WriterTo.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rb</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>) <span style=color:#75715e>// implements WriteTo.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>wb</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>Buffer</span>)  
</span></span><span style=display:flex><span><span style=color:#a6e22e>rb</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#e6db74>&#34;hello, world.&#34;</span>)  
</span></span><span style=display:flex><span><span style=color:#a6e22e>Copy</span>(<span style=color:#a6e22e>wb</span>, <span style=color:#a6e22e>rb</span>)  
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>wb</span>.<span style=color:#a6e22e>String</span>() <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;hello, world.&#34;</span> {  
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;Copy did not work properly&#34;</span>)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>基本要旨是你要定义一个底层的接口及其所需要的方法,这就是你传递的内容.然后你就拥有一个或多个可选的接口,你可以检查传递的类型是否满足,如果满足就可以调用该接口的方法,如果不满足则恢复默认行为.这种情况下不需要类型嵌入.</p><p>接口的嵌入更多的是关于多态的而不是鸭子类型.举个例子,如果你要访问数据库,但是想处理标准的数据库调用和事务内调用,你可以创建一个包含了两个类型(<code>sql.DB</code>和<code>sql.Tx</code>)的共同方法的接口,如下所示:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>dber</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Query</span>(<span style=color:#a6e22e>query</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>args</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>interface</span>{}) (<span style=color:#f92672>*</span><span style=color:#a6e22e>sql</span>.<span style=color:#a6e22e>Rows</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>QueryRow</span>(<span style=color:#a6e22e>query</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>args</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>interface</span>{}) <span style=color:#f92672>*</span><span style=color:#a6e22e>sql</span>.<span style=color:#a6e22e>Row</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Exec</span>(<span style=color:#a6e22e>query</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>args</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>interface</span>{}) (<span style=color:#a6e22e>sql</span>.<span style=color:#a6e22e>Result</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>DBHandle</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dber</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在你可以在<code>DBHandle</code>的匿名字段<code>dber</code>中存储<code>sql.DB</code>或者<code>sql.Tx</code>类型的值.任何使用<code>DBHandle</code>包括它自己的方法中都可以调用<code>Query()</code>,<code>QueryRow()</code>和<code>Exec()</code>而不需要知道他们是否在事务范围内被调用.当然了前提是必须先初始化<code>DBHandle</code>的<code>dber</code>字段的值.</p></section><div class=paginator><a class=prev href=https://echotrue.github.io/blog/101/variant-length-encode/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>Variant Length Encode</span></a>
<a class=next href=https://echotrue.github.io/blog/golang/http-response-body/><span>http.Response.Body未被完全读取的问题</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://echotrue.github.io/>AXLROSE</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
Theme by
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>