<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Golang Select</title>
<meta charset=utf-8><meta name=description content="Ladder@什么是select select语句用于从多个发送/接收channel中进行选择的操作。 select语句将阻塞直到其中一个发送/接收操作准备就"><meta name=author content="Axlrose"><link rel=canonical href=https://echotrue.github.io/blog/golang/golang-select/><link rel=alternate type=application/rss+xml href=https://echotrue.github.io//index.xml title=AXLROSE><meta property="og:url" content="https://echotrue.github.io/blog/golang/golang-select/"><meta property="og:site_name" content="AXLROSE"><meta property="og:title" content="Golang Select"><meta property="og:description" content="什么是select select语句用于从多个发送/接收channel中进行选择的操作。 select语句将阻塞直到其中一个发送/接收操作准备就"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-07-30T19:04:35+08:00"><meta property="article:modified_time" content="2019-07-30T19:04:35+08:00"><meta property="article:tag" content="Select"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://echotrue.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Golang","item":"https://echotrue.github.io/blog/golang/"},{"@type":"ListItem","position":3,"name":"Golang Select","item":"https://echotrue.github.io/blog/golang/golang-select/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang Select","name":"Golang Select","description":"什么是select select语句用于从多个发送/接收channel中进行选择的操作。 select语句将阻塞直到其中一个发送/接收操作准备就","keywords":["select"],"articleBody":"什么是select select语句用于从多个发送/接收channel中进行选择的操作。 select语句将阻塞直到其中一个发送/接收操作准备就绪。如果有多个操作就绪，则随机选择其中一个操作。语法类似于switch，只是每个case语句被一个channel操作取代了。让我们深入研究一些代码，以便更好地理解\nfunc server1(ch chan string) { time.Sleep(6 * time.Second) ch \u003c- \"from server1\" } func server2(ch chan string) { time.Sleep(3 * time.Second) ch \u003c- \"from server2\" } func main() { output1 := make(chan string) output2 := make(chan string) go server1(output1) go server2(output2) select { case s1 := \u003c-output1: fmt.Println(s1) case s2 := \u003c-output2: fmt.Println(s2) } } 在上面的程序中，在第 8 行server1函数休眠 6 秒然后将文本从server1写入channel ch。第 12 行server2函数休眠 3 秒，然后从server2写入channel ch。\nmain函数在 20 和 21 行分别调用server1和server2。\n在第 22 行，select语句将阻塞直到其中一个case准备就绪。在上面的程序中，server1在 6 秒后写入output1 channel，而server2在 3 秒后写入output2 channel。因此 select 语句将阻塞 3 秒并等待server2写入。 3 秒后，程序将打印，\nfrom server2 然后终止。\nselect的用途 将上述程序中的函数命名为server1和server2的原因是为了说明select的实际用途。\n让我们假设我们有一个关键任务的应用，我们需要尽快将输出返回给用户。该应用程序的数据库被复制并存储在世界各地的不同服务器中。假设函数server1和server2实际上与 2 个这样的服务器通信。每个服务器的响应时间取决于每个服务器的负载和网络延迟。我们将请求发送到两个服务器，然后使用select语句在相应的channel上等待响应。select会选择优先响应的服务器，其他响应被忽略。这样我们就可以向多个服务器发送相同的请求，并将最快的响应返回给用户:)。\n默认case 当其他case都没有准备就绪时，将会执行select语句中的默认case。这通常用于防止select语句阻塞。\nfunc process(ch chan string) { time.Sleep(10500 * time.Millisecond) ch \u003c- \"process successful\" } func main() { ch := make(chan string) go process(ch) for { time.Sleep(1000 * time.Millisecond) select { case v := \u003c-ch: fmt.Println(\"received value: \", v) return default: fmt.Println(\"no value received\") } } } 在上面的程序中，在第 8 行process函数休眠 10500 毫秒（10.5 秒），然后将process successful写入ch channel。该函数在第 15 行被并发调用。\n在并发调用process Goroutine之后，main Goroutine中启动了无限循环。无限循环在每次迭代开始期间休眠 1000 毫秒（1 秒），并执行select操作。在前 10500 毫秒期间，select语句的第一种情况即case v：= \u003c-ch：将不会准备就绪，因为process Goroutine仅在 10500 毫秒后才写入ch channel。因此，在此期间将执行defualt分支，程序将会打印 10 次no value received。\n在 10.5 秒之后，process Goroutine将process successful写入ch。 现在将执行select语句的第一种情况，程序将打印received value: process successful然后程序终止。该程序将输出，\nno value received no value received no value received no value received no value received no value received no value received no value received no value received no value received received value: process successful 死锁和默认case func main() { ch := make(chan string) select { case \u003c-ch: } } 在上面的程序中，我们在第一行创建了一个channel ch。我们尝试从选择的这个channel读取。而这个select语句将一直阻塞，因为没有其他Goroutine写入此channel，因此将导致死锁。该程序将在运行时产生panic同时打印，\nfatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: main.main() /tmp/sandbox416567824/main.go:6 +0x80 如果存在默认case，则不会发生此死锁，因为在没有其他case准备就绪时将执行默认case。上面的程序可以重写。\nfunc main() { ch := make(chan string) select { case \u003c-ch: default: fmt.Println(\"default case executed\") } } 输出，\ndefault case executed 类似地，当select只有一个nil channel，也会执行默认case。\nfunc main() { var ch chan string select { case v := \u003c-ch: fmt.Println(\"received value\", v) default: fmt.Println(\"default case executed\") } } 在上面的程序中，ch是nil，我们试图用select从ch中读取。如果没有默认case，则select将一直被阻塞并导致死锁。由于我们在select中有一个默认的case，它将被执行并且程序将打印，\ndefault case executed select的随机性 当select语句中的多个case准备就绪时，将会随机挑选一个执行。\nfunc server1(ch chan string) { ch \u003c- \"from server1\" } func server2(ch chan string) { ch \u003c- \"from server2\" } func main() { output1 := make(chan string) output2 := make(chan string) go server1(output1) go server2(output2) time.Sleep(1 * time.Second) select { case s1 := \u003c-output1: fmt.Println(s1) case s2 := \u003c-output2: fmt.Println(s2) } } 在上面的程序中，server1和server2 协程在第 18 和 19 行分别被调用，然后main协程休眠 1 秒。当运行到select语句时，server1已将from server1写入output1，server2已将from server2写入output2，因此select语句中的两种情况都准备就绪。如果多次运行此程序，将会随机输出from server1或from server2。\n空select func main() { select {} } 你认为上面的程序将会输出什么？\n我们知道select语句将被阻塞，直到执行其中一个case。在这种情况下，select语句没有任何case，因此它将一直阻塞导致死锁。这个程序将会产生panic，并输出，\nfatal error: all goroutines are asleep - deadlock! goroutine 1 [select (no cases)]: main.main() /tmp/sandbox299546399/main.go:4 +0x20 ","wordCount":"2080","inLanguage":"en","datePublished":"2019-07-30T19:04:35+08:00","dateModified":"2019-07-30T19:04:35+08:00","author":{"@type":"Person","name":"Axlrose"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://echotrue.github.io/blog/golang/golang-select/"},"publisher":{"@type":"Organization","name":"AXLROSE","logo":{"@type":"ImageObject","url":"https://echotrue.github.io/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css><link rel=stylesheet href=/css/main.min.041a458015951c8bc9a981a7927109c808f4e247b9920f71ecf5cfd9125f6878.css integrity="sha256-BBpFgBWVHIvJqYGnknEJyAj04ke5kg9x7PXP2RJfaHg=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/atom-one-dark.min.d51fd0897056947c1a907d5753da4b37e67f6c13b4ec4c836708e028a1b5687a.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/blog>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/series>Series</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/book>Book</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Golang Select</h1></header><p><small>July 30, 2019&nbsp;· 2080 words&nbsp;· 5 min</small>
<small>·
<a href=https://echotrue.github.io/tags/select/>Select</a></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><ul><li><a href=#什么是select>什么是select</a></li><li><a href=#select的用途>select的用途</a></li><li><a href=#默认case>默认case</a></li><li><a href=#死锁和默认case>死锁和默认case</a></li><li><a href=#select的随机性>select的随机性</a></li><li><a href=#空select>空select</a></li></ul></li></ul></nav></div><section class=blog-content><h3 id=什么是select>什么是select</h3><p><code>select</code>语句用于从多个发送/接收<code>channel</code>中进行选择的操作。 <code>select</code>语句将阻塞直到其中一个发送/接收操作准备就绪。如果有多个操作就绪，则随机选择其中一个操作。语法类似于<code>switch</code>，只是每个<code>case</code>语句被一个<code>channel</code>操作取代了。让我们深入研究一些代码，以便更好地理解</p><pre tabindex=0><code>func server1(ch chan string) {
    time.Sleep(6 * time.Second)
    ch &lt;- &#34;from server1&#34;
}
func server2(ch chan string) {
    time.Sleep(3 * time.Second)
    ch &lt;- &#34;from server2&#34;

}
func main() {
    output1 := make(chan string)
    output2 := make(chan string)
    go server1(output1)
    go server2(output2)
    select {
    case s1 := &lt;-output1:
        fmt.Println(s1)
    case s2 := &lt;-output2:
        fmt.Println(s2)
    }
}
</code></pre><p>在上面的程序中，在第 8 行<code>server1</code>函数休眠 6 秒然后将文本从<code>server1</code>写入<code>channel ch</code>。第 12 行<code>server2</code>函数休眠 3 秒，然后从<code>server2</code>写入<code>channel ch</code>。</p><p><code>main</code>函数在 20 和 21 行分别调用<code>server1</code>和<code>server2</code>。</p><p>在第 22 行，<code>select</code>语句将阻塞直到其中一个<code>case</code>准备就绪。在上面的程序中，<code>server1</code>在 6 秒后写入<code>output1 channel</code>，而<code>server2</code>在 3 秒后写入<code>output2 channel</code>。因此 select 语句将阻塞 3 秒并等待<code>server2</code>写入。 3 秒后，程序将打印，</p><pre tabindex=0><code>from server2
</code></pre><p>然后终止。</p><h3 id=select的用途>select的用途</h3><p>将上述程序中的函数命名为<code>server1</code>和<code>server2</code>的原因是为了说明<code>select</code>的实际用途。</p><p>让我们假设我们有一个关键任务的应用，我们需要尽快将输出返回给用户。该应用程序的数据库被复制并存储在世界各地的不同服务器中。假设函数<code>server1</code>和<code>server2</code>实际上与 2 个这样的服务器通信。每个服务器的响应时间取决于每个服务器的负载和网络延迟。我们将请求发送到两个服务器，然后使用<code>select</code>语句在相应的<code>channel</code>上等待响应。<code>select</code>会选择优先响应的服务器，其他响应被忽略。这样我们就可以向多个服务器发送相同的请求，并将最快的响应返回给用户:)。</p><h3 id=默认case>默认case</h3><p>当其他<code>case</code>都没有准备就绪时，将会执行<code>select</code>语句中的默认<code>case</code>。这通常用于防止<code>select</code>语句阻塞。</p><pre tabindex=0><code>func process(ch chan string) {
    time.Sleep(10500 * time.Millisecond)
    ch &lt;- &#34;process successful&#34;
}

func main() {
    ch := make(chan string)
    go process(ch)
    for {
        time.Sleep(1000 * time.Millisecond)
        select {
        case v := &lt;-ch:
            fmt.Println(&#34;received value: &#34;, v)
            return
        default:
            fmt.Println(&#34;no value received&#34;)
        }
    }

}
</code></pre><p>在上面的程序中，在第 8 行<code>process</code>函数休眠 10500 毫秒（10.5 秒），然后将<code>process successful</code>写入<code>ch channel</code>。该函数在第 15 行被并发调用。</p><p>在并发调用<code>process Goroutine</code>之后，<code>main Goroutine</code>中启动了无限循环。无限循环在每次迭代开始期间休眠 1000 毫秒（1 秒），并执行<code>select</code>操作。在前 10500 毫秒期间，<code>select</code>语句的第一种情况即<code>case v：= &lt;-ch：</code>将不会准备就绪，因为<code>process Goroutine</code>仅在 10500 毫秒后才写入<code>ch channel</code>。因此，在此期间将执行<code>defualt</code>分支，程序将会打印 10 次<code>no value received</code>。</p><p>在 10.5 秒之后，<code>process Goroutine</code>将<code>process successful</code>写入<code>ch</code>。 现在将执行<code>select</code>语句的第一种情况，程序将打印<code>received value: process successful</code>然后程序终止。该程序将输出，</p><pre tabindex=0><code>no value received
no value received
no value received
no value received
no value received
no value received
no value received
no value received
no value received
no value received
received value:  process successful
</code></pre><h3 id=死锁和默认case>死锁和默认case</h3><pre tabindex=0><code>func main() {
    ch := make(chan string)
    select {
    case &lt;-ch:
    }
}
</code></pre><p>在上面的程序中，我们在第一行创建了一个<code>channel ch</code>。我们尝试从选择的这个<code>channel</code>读取。而这个<code>select</code>语句将一直阻塞，因为没有其他<code>Goroutine</code>写入此<code>channel</code>，因此将导致死锁。该程序将在运行时产生<code>panic</code>同时打印，</p><pre tabindex=0><code>fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan receive]:
main.main()
    /tmp/sandbox416567824/main.go:6 +0x80
</code></pre><p>如果存在默认<code>case</code>，则不会发生此死锁，因为在没有其他<code>case</code>准备就绪时将执行默认<code>case</code>。上面的程序可以重写。</p><pre tabindex=0><code>func main() {
    ch := make(chan string)
    select {
    case &lt;-ch:
    default:
        fmt.Println(&#34;default case executed&#34;)
    }
}
</code></pre><p>输出，</p><pre tabindex=0><code>default case executed
</code></pre><p>类似地，当<code>select</code>只有一个<code>nil channel</code>，也会执行默认<code>case</code>。</p><pre tabindex=0><code>func main() {
    var ch chan string
    select {
    case v := &lt;-ch:
        fmt.Println(&#34;received value&#34;, v)
    default:
        fmt.Println(&#34;default case executed&#34;)

    }
}
</code></pre><p>在上面的程序中，<code>ch</code>是<code>nil</code>，我们试图用<code>select</code>从<code>ch</code>中读取。如果没有默认<code>case</code>，则<code>select</code>将一直被阻塞并导致死锁。由于我们在<code>select</code>中有一个默认的<code>case</code>，它将被执行并且程序将打印，</p><pre tabindex=0><code>default case executed
</code></pre><h3 id=select的随机性>select的随机性</h3><p>当<code>select</code>语句中的多个<code>case</code>准备就绪时，将会随机挑选一个执行。</p><pre tabindex=0><code>func server1(ch chan string) {
    ch &lt;- &#34;from server1&#34;
}
func server2(ch chan string) {
    ch &lt;- &#34;from server2&#34;

}
func main() {
    output1 := make(chan string)
    output2 := make(chan string)
    go server1(output1)
    go server2(output2)
    time.Sleep(1 * time.Second)
    select {
    case s1 := &lt;-output1:
        fmt.Println(s1)
    case s2 := &lt;-output2:
        fmt.Println(s2)
    }
}
</code></pre><p>在上面的程序中，<code>server1</code>和<code>server2</code> 协程在第 18 和 19 行分别被调用，然后<code>main</code>协程休眠 1 秒。当运行到<code>select</code>语句时，<code>server1</code>已将<code>from server1</code>写入<code>output1</code>，<code>server2</code>已将<code>from server2</code>写入<code>output2</code>，因此<code>select</code>语句中的两种情况都准备就绪。如果多次运行此程序，将会随机输出<code>from server1</code>或<code>from server2</code>。</p><h3 id=空select>空select</h3><pre tabindex=0><code>func main() {
    select {}
}
</code></pre><p>你认为上面的程序将会输出什么？</p><p>我们知道<code>select</code>语句将被阻塞，直到执行其中一个<code>case</code>。在这种情况下，<code>select</code>语句没有任何<code>case</code>，因此它将一直阻塞导致死锁。这个程序将会产生<code>panic</code>，并输出，</p><pre tabindex=0><code>fatal error: all goroutines are asleep - deadlock!

goroutine 1 [select (no cases)]:
main.main()
    /tmp/sandbox299546399/main.go:4 +0x20
</code></pre></section><div class=paginator><a class=prev href=https://echotrue.github.io/blog/golang/panic-and-recover/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>Panic and Recover</span></a>
<a class=next href=https://echotrue.github.io/blog/zh/videos.zh/><span>Videos</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://echotrue.github.io/>AXLROSE</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
Theme by
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>