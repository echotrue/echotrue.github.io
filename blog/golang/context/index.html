<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Context</title>
<meta charset=utf-8><meta name=description content="Ladder@引言 Golang的Context包是专门用来简化对于处理单个请求的多个goroutine之间与请求域的数据，取消信号，截止时间等相关操作。 一"><meta name=author content="Axlrose"><link rel=canonical href=https://echotrue.github.io/blog/golang/context/><link rel=alternate type=application/rss+xml href=https://echotrue.github.io//index.xml title=AXLROSE><meta property="og:url" content="https://echotrue.github.io/blog/golang/context/"><meta property="og:site_name" content="AXLROSE"><meta property="og:title" content="Context"><meta property="og:description" content="引言 Golang的Context包是专门用来简化对于处理单个请求的多个goroutine之间与请求域的数据，取消信号，截止时间等相关操作。 一"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2020-10-03T15:13:54+08:00"><meta property="article:modified_time" content="2020-10-03T15:13:54+08:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Context"><meta property="og:see_also" content="https://echotrue.github.io/blog/golang/read-context-again/"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://echotrue.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Context","item":"https://echotrue.github.io/blog/golang/context/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Context","name":"Context","description":"引言 Golang的Context包是专门用来简化对于处理单个请求的多个goroutine之间与请求域的数据，取消信号，截止时间等相关操作。 一","keywords":["Go","Context"],"articleBody":"引言 Golang的Context包是专门用来简化对于处理单个请求的多个goroutine之间与请求域的数据，取消信号，截止时间等相关操作。 一个实际的例子是：\n在Go服务器程序中，每个请求都会有一个goroutine去处理。然而，处理程序可能还需要创建额外的goroutine去访问其他资源，比如：数据库， RPC服务等。由于这些goroutine都是在处理同一个请求，所以他们往往需要访问一些共享的资源，比如：用户身份信息，认证token ，请求截止时间等。当请求超时或者被取消后，所有的goroutine都应该马上退出并且释放相关的资源。这种情况也需要用Context来为我们来取消掉所有 的goroutine\nContext定义 context的主要数据结构是一种嵌套的结构或者说是单向的继承关系的结构，比如最初的context是一个小盒子，里面装了一些数据， 之后从这个context继承下来的children就像在原本的context中又套上了一个盒子，然后里面装着一些自己的数据。或者说context是一种分层的结构， 根据使用场景的不同，每一层context都具备有一些不同的特性，这种层级式的组织也使得context易于扩展，职责清晰。\ncontext包的核心是interface Context ,声明如下：\ntype Context interface { Deadline() (deadline time.Time, ok bool) Done() \u003c-chan struct{} Err() error Value(key interface{}) interface{} } Context定义很简单，一共四个方法：\nDeadline方法是获取设置的截止时间的意思，第一个返回式是截止时间，到了这个时间点，Context会自动发起取消请求； 第二个返回值ok==false时表示没有设置截止时间，如果需要取消的话，需要调用取消函数进行取消。 Done方法返回一个只读的chan，类型为struct{}，我们在goroutine中，如果该方法返回的chan可以读取， 则意味着parent context已经发起了取消请求，我们通过Done方法收到这个信号后，就应该做清理操作，然后退出goroutine，释放资源。之后，Err 方法会返回一个错误，告知为什么 Context 被取消。 Err方法返回取消的错误原因，因为什么Context被取消。 Value方法获取该Context上绑定的值，是一个键值对，所以要通过一个Key才可以获取对应的值，这个值一般是线程安全的。 Context的实现方法 Context 虽然是个接口，但是并不需要使用方实现，golang内置的context 包，已经帮我们实现了2个方法，一般在代码中， 开始上下文的时候都是以这两个作为最顶层的parent context，然后再衍生出子context。这些 Context 对象形成一棵树： 当一个 Context 对象被取消时，继承自它的所有 Context 都会被取消。两个实现如下：\nvar ( background = new(emptyCtx) todo = new(emptyCtx) ) func Background() Context { return background } func TODO() Context { return todo } 一个是Background，主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context，它不能被取消。 一个是TODO，如果我们不知道该使用什么Context的时候，可以使用这个，但是实际应用中，暂时还没有使用过这个TODO。 他们两个本质上都是emptyCtx结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。 type emptyCtx int func (*emptyCtx) Deadline() (deadline time.Time, ok bool) { return } func (*emptyCtx) Done() \u003c-chan struct{} { return nil } func (*emptyCtx) Err() error { return nil } func (*emptyCtx) Value(key interface{}) interface{} { return nil } Context的继承 有了如上的根Context，那么是如何衍生更多的子Context的呢？这就要靠context包为我们提供的With系列的函数了。\nfunc WithCancel(parent Context) (ctx Context, cancel CancelFunc) func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) func WithValue(parent Context, key, val interface{}) Context 通过这些函数，就创建了一颗Context树，树的每个节点都可以有任意多个子节点，节点层级可以有任意多个。\nWithCancel函数，传递一个父Context作为参数，返回子Context，以及一个取消函数用来取消Context。 WithDeadline函数，和WithCancel差不多，它会多传递一个截止时间参数，意味着到了这个时间点，会自动取消Context，当然我们也可以不等到这个时候，可以提前通过取消函数进行取消。 WithTimeout和WithDeadline基本上一样，这个表示是超时自动取消，是多少时间后自动取消Context的意思。 WithValue函数和取消Context无关，它是为了生成一个绑定了一个键值对数据的Context，这个绑定的数据可以通过Context.Value方法访问到，这是我们实际用经常要用到的技巧，一般我们想要通过上下文来传递数据时，可以通过这个方法，如我们需要tarce追踪系统调用栈的时候。 Context使用技巧和原则 不要把Context放在结构体中，要以参数的方式传递，parent Context一般为Background 应该要把Context作为第一个参数传递给入口请求和出口请求链路上的每一个函数，放在第一位，变量名建议都统一，如ctx。 给一个函数方法传递Context的时候，不要传递nil，否则在tarce追踪的时候，就会断了连接 Context的Value相关方法应该传递必须的数据，不要什么数据都使用这个传递 Context是线程安全的，可以放心的在多个goroutine中传递 可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。 Context使用示例 请求链路传值 func func1(ctx context.Context) { ctx = context.WithValue(ctx, \"k1\", \"v1\") func2(ctx) } func func2(ctx context.Context) { fmt.Println(ctx.Value(\"k1\").(string)) } func main() { ctx := context.Background() func1(ctx) } 我们在func1通过WithValue(parent Context, key, val interface{}) Context，赋值k1为v1， 在其下层函数func2通过ctx.Value(key interface{}) interface{}获取k1的值，比较简单。这里有个疑问，如果我是在func2里赋值， 在func1里面能够拿到这个值吗？答案是不能，context只能自上而下携带值，这个是要注意的一点。\n取消耗时操作，及时释放资源 主动取消 func func1(ctx context.Context, wg *sync.WaitGroup) error { defer wg.Done() respC := make(chan int) // 处理逻辑 go func() { time.Sleep(time.Second * 5) respC \u003c- 10 }() // 取消机制 select { case \u003c-ctx.Done(): fmt.Println(\"cancel.\") return errors.New(\"cancel\") case r := \u003c-respC: fmt.Println(r) return nil } } func main() { wg := new(sync.WaitGroup) ctx, cancel := context.WithCancel(context.Background()) wg.Add(1) go func1(ctx, wg) time.Sleep(time.Second * 2) cancel() wg.Wait() } 超时取消 func func1(ctx context.Context) { hctx, hcancel := context.WithTimeout(ctx, time.Second*4) defer hcancel() resp := make(chan struct{}, 1) go func() { // 处理耗时操作 time.Sleep(time.Second * 10) resp \u003c- struct{}{} }() select { // case \u003c-ctx.Done(): // fmt.Println(\"ctx timeout\") // fmt.Println(\"退出\",ctx.Err()) case \u003c-hctx.Done(): fmt.Println(\"hctx timeout\") fmt.Println(hctx.Err()) case v := \u003c-resp: fmt.Println(\"test2 function handle done\") fmt.Printf(\"result:%v\\n\", v) } fmt.Println(\"test2 finish\") fmt.Println(time.Now().Unix()) return } func main() { fmt.Println(time.Now().Unix()) ctx, cancel := context.WithTimeout(context.Background(), time.Second*2) defer cancel() func1(ctx) } ","wordCount":"2597","inLanguage":"en","datePublished":"2020-10-03T15:13:54+08:00","dateModified":"2020-10-03T15:13:54+08:00","author":{"@type":"Person","name":"Axlrose"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://echotrue.github.io/blog/golang/context/"},"publisher":{"@type":"Organization","name":"AXLROSE","logo":{"@type":"ImageObject","url":"https://echotrue.github.io/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css><link rel=stylesheet href=/css/main.min.e196d9ab5d83e9373fc94cbe17793a8f1224c1f72b4e871fd98ddad7d3f29fec.css integrity="sha256-4ZbZq12D6Tc/yUy+F3k6jxIkwfcrTocf2Y3a19Pyn+w=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/atom-one-dark.min.d51fd0897056947c1a907d5753da4b37e67f6c13b4ec4c836708e028a1b5687a.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/blog>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/series>Series</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/book>Book</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Context</h1></header><p><small>October 3, 2020&nbsp;· 2597 words&nbsp;· 6 min</small>
<small>·
<a href=https://echotrue.github.io/tags/go/>Go</a>
<a href=https://echotrue.github.io/tags/context/>Context</a></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><ul><li><a href=#引言>引言</a></li><li><a href=#context定义>Context定义</a></li><li><a href=#context的实现方法>Context的实现方法</a></li><li><a href=#context的继承>Context的继承</a></li><li><a href=#context使用技巧和原则>Context使用技巧和原则</a></li><li><a href=#context使用示例>Context使用示例</a></li></ul></li></ul></nav></div><section class=blog-content><h3 id=引言>引言</h3><p><code>Golang</code>的<code>Context</code>包是专门用来简化对于处理单个请求的多个<code>goroutine</code>之间与请求域的数据，取消信号，截止时间等相关操作。
一个实际的例子是：</p><blockquote><p>在<code>Go</code>服务器程序中，每个请求都会有一个<code>goroutine</code>去处理。然而，处理程序可能还需要创建额外的<code>goroutine</code>去访问其他资源，比如：数据库，
RPC服务等。由于这些<code>goroutine</code>都是在处理同一个请求，所以他们往往需要访问一些共享的资源，比如：用户身份信息，认证token
，请求截止时间等。当请求超时或者被取消后，所有的<code>goroutine</code>都应该马上退出并且释放相关的资源。这种情况也需要用<code>Context</code>来为我们来取消掉所有
的<code>goroutine</code></p></blockquote><h3 id=context定义>Context定义</h3><p><code>context</code>的主要数据结构是一种嵌套的结构或者说是单向的继承关系的结构，比如最初的context是一个小盒子，里面装了一些数据，
之后从这个context继承下来的children就像在原本的context中又套上了一个盒子，然后里面装着一些自己的数据。或者说context是一种分层的结构，
根据使用场景的不同，每一层context都具备有一些不同的特性，这种层级式的组织也使得context易于扩展，职责清晰。</p><p><code>context</code>包的核心是<code>interface Context</code> ,声明如下：</p><pre tabindex=0><code>type Context interface {

Deadline() (deadline time.Time, ok bool)

Done() &lt;-chan struct{}

Err() error

Value(key interface{}) interface{}

}
</code></pre><p><code>Context</code>定义很简单，一共四个方法：</p><ol><li>Deadline方法是获取设置的截止时间的意思，第一个返回式是截止时间，到了这个时间点，Context会自动发起取消请求；
第二个返回值ok==false时表示没有设置截止时间，如果需要取消的话，需要调用取消函数进行取消。</li><li>Done方法返回一个只读的chan，类型为struct{}，我们在goroutine中，如果该方法返回的chan可以读取，
则意味着parent context已经发起了取消请求，我们通过Done方法收到这个信号后，就应该做清理操作，然后退出goroutine，释放资源。之后，Err 方法会返回一个错误，告知为什么 Context 被取消。</li><li>Err方法返回取消的错误原因，因为什么Context被取消。</li><li>Value方法获取该Context上绑定的值，是一个键值对，所以要通过一个Key才可以获取对应的值，这个值一般是线程安全的。</li></ol><h3 id=context的实现方法>Context的实现方法</h3><p><code>Context</code> 虽然是个接口，但是并不需要使用方实现，<code>golang</code>内置的<code>context</code> 包，已经帮我们实现了2个方法，一般在代码中，
开始上下文的时候都是以这两个作为最顶层的<code>parent context</code>，然后再衍生出子<code>context</code>。这些 <code>Context</code> 对象形成一棵树：
当一个 <code>Context</code> 对象被取消时，继承自它的所有 <code>Context</code> 都会被取消。两个实现如下：</p><pre tabindex=0><code>var (
    background = new(emptyCtx)
    todo = new(emptyCtx)
)

func Background() Context {
    return background
}

func TODO() Context {
    return todo
}
</code></pre><ol><li>一个是Background，主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context，它不能被取消。</li><li>一个是TODO，如果我们不知道该使用什么Context的时候，可以使用这个，但是实际应用中，暂时还没有使用过这个TODO。</li><li>他们两个本质上都是emptyCtx结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。</li></ol><pre tabindex=0><code>type emptyCtx int

func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {
    
    return
}

func (*emptyCtx) Done() &lt;-chan struct{} {

    return nil
}

func (*emptyCtx) Err() error {

    return nil
}

func (*emptyCtx) Value(key interface{}) interface{} {

    return nil
}
</code></pre><h3 id=context的继承>Context的继承</h3><p>有了如上的根Context，那么是如何衍生更多的子Context的呢？这就要靠context包为我们提供的With系列的函数了。</p><pre tabindex=0><code>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)

func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)

func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)

func WithValue(parent Context, key, val interface{}) Context
</code></pre><p>通过这些函数，就创建了一颗Context树，树的每个节点都可以有任意多个子节点，节点层级可以有任意多个。</p><ol><li>WithCancel函数，传递一个父Context作为参数，返回子Context，以及一个取消函数用来取消Context。</li><li>WithDeadline函数，和WithCancel差不多，它会多传递一个截止时间参数，意味着到了这个时间点，会自动取消Context，当然我们也可以不等到这个时候，可以提前通过取消函数进行取消。</li><li>WithTimeout和WithDeadline基本上一样，这个表示是超时自动取消，是多少时间后自动取消Context的意思。</li><li>WithValue函数和取消Context无关，它是为了生成一个绑定了一个键值对数据的Context，这个绑定的数据可以通过Context.Value方法访问到，这是我们实际用经常要用到的技巧，一般我们想要通过上下文来传递数据时，可以通过这个方法，如我们需要tarce追踪系统调用栈的时候。</li></ol><h3 id=context使用技巧和原则>Context使用技巧和原则</h3><ul><li>不要把Context放在结构体中，要以参数的方式传递，parent Context一般为Background</li><li>应该要把Context作为第一个参数传递给入口请求和出口请求链路上的每一个函数，放在第一位，变量名建议都统一，如ctx。</li><li>给一个函数方法传递Context的时候，不要传递nil，否则在tarce追踪的时候，就会断了连接</li><li>Context的Value相关方法应该传递必须的数据，不要什么数据都使用这个传递</li><li>Context是线程安全的，可以放心的在多个goroutine中传递</li><li>可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。</li></ul><h3 id=context使用示例>Context使用示例</h3><h4 id=请求链路传值>请求链路传值</h4><pre tabindex=0><code>func func1(ctx context.Context) {
    ctx = context.WithValue(ctx, &#34;k1&#34;, &#34;v1&#34;)
    func2(ctx)
}

func func2(ctx context.Context) {
    fmt.Println(ctx.Value(&#34;k1&#34;).(string))
}
func main() {
    ctx := context.Background()
    func1(ctx)
}
</code></pre><p>我们在<code>func1</code>通过<code>WithValue(parent Context, key, val interface{}) Context</code>，赋值k1为v1，
在其下层函数<code>func2</code>通过<code>ctx.Value(key interface{}) interface{}</code>获取k1的值，比较简单。这里有个疑问，如果我是在<code>func2</code>里赋值，
在<code>func1</code>里面能够拿到这个值吗？答案是不能，<code>context</code>只能自上而下携带值，这个是要注意的一点。</p><h4 id=取消耗时操作及时释放资源>取消耗时操作，及时释放资源</h4><h5 id=主动取消>主动取消</h5><pre tabindex=0><code>func func1(ctx context.Context, wg *sync.WaitGroup) error {
    defer wg.Done()
    respC := make(chan int)
    // 处理逻辑
    go func() {
        time.Sleep(time.Second * 5)
        respC &lt;- 10
    }()
    // 取消机制
    select {
    case &lt;-ctx.Done():
        fmt.Println(&#34;cancel.&#34;)
        return errors.New(&#34;cancel&#34;)
    case r := &lt;-respC:
        fmt.Println(r)
        return nil
    }
}

func main() {
    wg := new(sync.WaitGroup)
    ctx, cancel := context.WithCancel(context.Background())
    wg.Add(1)
    go func1(ctx, wg)
    time.Sleep(time.Second * 2)
    cancel()
    wg.Wait()
}
</code></pre><h5 id=超时取消>超时取消</h5><pre tabindex=0><code>func func1(ctx context.Context) {
    hctx, hcancel := context.WithTimeout(ctx, time.Second*4)
    defer hcancel()
    
    resp := make(chan struct{}, 1)
    
    go func() {
        // 处理耗时操作
        time.Sleep(time.Second * 10)
        resp &lt;- struct{}{}
    }()
    
    select {
    // case &lt;-ctx.Done():
    // 	fmt.Println(&#34;ctx timeout&#34;)
    // 	fmt.Println(&#34;退出&#34;,ctx.Err())
    case &lt;-hctx.Done():
        fmt.Println(&#34;hctx timeout&#34;)
        fmt.Println(hctx.Err())
    case v := &lt;-resp:
        fmt.Println(&#34;test2 function handle done&#34;)
        fmt.Printf(&#34;result:%v\n&#34;, v)
    }
    fmt.Println(&#34;test2 finish&#34;)
    fmt.Println(time.Now().Unix())
    return
}

func main() {
    fmt.Println(time.Now().Unix())
    ctx, cancel := context.WithTimeout(context.Background(), time.Second*2)
    defer cancel()
    func1(ctx)
}
</code></pre></section><div class=paginator><a class=prev href=https://echotrue.github.io/blog/algorithm/golang-search-slice/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>Golang Search Slice</span></a>
<a class=next href=https://echotrue.github.io/blog/golang/data-races/><span>Golang Data Races</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=related-resources></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://echotrue.github.io/>AXLROSE</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
Theme by
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>