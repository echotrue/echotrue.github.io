<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Sqlx</title>
<meta charset=utf-8><meta name=description content="Ladder@Handle Types (引用类型) sqlx旨在和database/sql具有相同的感觉，他有四种引用类型 sqlx.DB 类似于sql.DB,是数据库的表示 sqlx.Tx类似"><meta name=author content="Axlrose"><link rel=canonical href=https://echotrue.github.io/blog/golang/sqlx/><link rel=alternate type=application/rss+xml href=https://echotrue.github.io//index.xml title=AXLROSE><meta property="og:url" content="https://echotrue.github.io/blog/golang/sqlx/"><meta property="og:site_name" content="AXLROSE"><meta property="og:title" content="Sqlx"><meta property="og:description" content="Handle Types (引用类型) sqlx旨在和database/sql具有相同的感觉，他有四种引用类型 sqlx.DB 类似于sql.DB,是数据库的表示 sqlx.Tx类似"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-08-04T14:50:30+08:00"><meta property="article:modified_time" content="2022-08-04T14:50:30+08:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Sqlx"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://echotrue.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Sqlx","item":"https://echotrue.github.io/blog/golang/sqlx/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Sqlx","name":"Sqlx","description":"Handle Types (引用类型) sqlx旨在和database/sql具有相同的感觉，他有四种引用类型 sqlx.DB 类似于sql.DB,是数据库的表示 sqlx.Tx类似","keywords":["Go","Sqlx"],"articleBody":"Handle Types (引用类型) sqlx旨在和database/sql具有相同的感觉，他有四种引用类型\nsqlx.DB 类似于sql.DB,是数据库的表示 sqlx.Tx类似于sql.Tx,是事务的表示 sqlx.Stmt类似于sql.Stmt,是预处理语句的表示 sqlx.NamedStmt是一种支持命名参数的预处理语句的表示 引用类型都嵌入了他们在database/sql中的等效物，这就意味着当你调用sqlx.DB.Query()，实际是调用与sql.DB.Query相同的代码。\n除此之外，还有两种光标类型：\nQuerying 101 (查询概述) 引用类型实现了以下相同的操作来查询数据库\nExec(...) (sql.Result, error) - unchanged from database/sql Query(...) (*sql.Rows, error) - unchanged from database/sql QueryRow(...) *sql.Row - unchanged from database/sql 以下这些是内置操作的扩展\nMustExec() sql.Result – Exec, but panic on error Queryx(...) (*sqlx.Rows, error) - Query, but return an sqlx.Rows QueryRowx(...) *sqlx.Row – QueryRow, but return an sqlx.Row 还有这些新的语义：\nGet(dest interface{}, ...) error Select(dest interface{}, ...) error Exec and MustExec 这两个方法都是用于执行插入，修改以及DDL语句。区别是他们的错误处理机制不一样，Exec会将结果和错误返回，由开发者自行处理。而MustExec遇到错误会抛出恐慌panic\n// Create table schema := `CREATE TABLE place (country text,city text NULL,telcode integer);` result, err := db.Exec(schema) if err != nil { log.Fatalln(err) } // Insert schema := `INSERT INTO place (country,telcode) VALUES (?,?)` result := db.MustExec(schema, \"Hong Kong\", 852) //result.LastInsertId() //result.RowsAffected() Query // fetch all places from the db rows, err := db.Query(\"SELECT country, city, telcode FROM place\") // iterate over each row for rows.Next() { var country string // note that city can be NULL, so we use the NullString type var city sql.NullString var telcode int err = rows.Scan(\u0026country, \u0026city, \u0026telcode) } // check the error from rows err = rows.Err() 应该像数据库游标一样看待Rows，而不是将其看作一个具体的结果集。尽管数据库驱动缓冲行为有所不同，但是通过Next()迭代能够有效的约束大型查询结果集的内存使用，因为一次只扫描一行。Scan()通过反射来将数据库列的类型映射到Go的类型，例如：string,[]byte等等。如果不迭代所有行的结果，请确保调用rows.Close()以便将连接返回到连接池。 Query查询返回的error是数据库服务preparing或executing过程中发生的任意错误。这些错误包含从连接池中获取无效的连接，尽管database/sql会重试10次来尝试找到或创建正常的连接。通常，这些错误是由SQL语法错误，类型错误，字段名和表明错误引起。 大多数情况下，Rows.Scan会复制其从数据库驱动中获取的数据，因为它不知道数据库驱动将会如何重复使用缓冲区。特殊类型sql.RawBytes可以用来从数据库驱动返回的实际数据中获取一个零拷贝的字节切片。下次调用Next()之后，这个值将不再有效，因为这个值所在的内存可能已经被覆盖。 Query查询使用的连接会一直保持活跃状态，直到通过Next()迭代完查询出的所有行，或者rows.Close()被调用。此时，连接才会被释放。 Queryx和Query用法基本一样，只是他返回一个sqlx.Rows对象，这个对象拥有更加丰富的scan行为可供选择。\ntype Place struct { Country string City sql.NullString TelephoneCode int `db:\"telcode\"` } rows, err := db.Queryx(\"SELECT * FROM place\") for rows.Next() { var p Place err = rows.StructScan(\u0026p) } StructScan()是sql.Rows主要的扩展行为，他会扫描查询结果并映射到结构体字段中。注意，这些字段必须是导出的（首字母大写），以便sqlx能够将数据写入，这个规则适用于Go中的所有类型（json,xml）的Marshalling(编码)和UNMarshalling(解码)。可以使用结构体标签db指定数据表列名和结构体字段的映射关系，或者使用db.MapperFunc()设置新的默认映射关系。默认是使用strings.Lower将结构体字段转小写来匹配数据表列名。\nQueryRow QueryRow从数据表提取一条记录。它从连接池中获取一个连接，然后通过Query执行查询，返回一个内部包含Rows对象的Row对象。 与Query不同，QueryRow返回没有错误的Row类型结果，使得对查询结果的链式Scan操作是安全的。如果执行查询过程中发生错误，错误会通过Scan返回。如果没有查询到结果，Scan返回sql.ErrNoRows错误。如果Scan本身发生错误（例如：类型不匹配）,错误同样会被返回。 查询结果Row内部的Rows结构体在Scan执行完后会关闭，这就意味着，QueryRow查询所在的数据库连接一直会保持到查询结果被扫描完。同样意味着sql.RawBytes在这里也不可用，由于被引用的内存块属于数据库驱动，并且调用返回时该内存块可能已经无效。 sqlx扩展的方法QueryRowx会返回sqlx.Row代替sql.Row，它实现了上述介绍以及高阶扫描中Rows相同的扫描扩展。\nGet and Select Get和Select是引用类型的节省时间的扩展，它将查询的执行和灵活的扫描语义相结合。为了清楚的解释它们，我们不得不谈论下什么是scannable(可扫描的)：\n不是结构体类型的值是可扫描的，例如：string, int 实现了sql.Scanner接口的值是可扫描的 没有导出字段的结构体可以是扫描的(eg. time.Time) Get和Select使用rows.Scan在可扫描类型上，使用rows.StructScan在不可扫描类型上。它们与QueryRow和Query大致相似，Get主要用来获取单条记录并扫描它，Select主要用来获取一个结果集。 p := Place{} pp := []Place{} // this will pull the first place directly into p err = db.Get(\u0026p, \"SELECT * FROM place LIMIT 1\") // this will pull places with telcode \u003e 50 into the slice pp err = db.Select(\u0026pp, \"SELECT * FROM place WHERE telcode \u003e ?\", 50) // they work with regular types as well var id int err = db.Get(\u0026id, \"SELECT count(*) FROM place\") // fetch at most 10 place names var names []string err = db.Select(\u0026names, \"SELECT name FROM place LIMIT 10\") Get和Select都将会关闭它们在查询执行过程中创建的Rows对象，并且返回在这个过程中发生的任何错误。由于它们在内部使用StructScan,因此\"高级扫描\"中介绍的部分也适用于这两个方法。 Select可以为你节省很多输入，但是，请谨记！它在语义上和Queryx不同，因为它会将整个查询结果集一次性的加载进内存，如果这个结果集没有被查询限制到一个合理的大小，使用经典的Queryx/StructScan迭代反而是更好的选择。\nTransactions (事务) 要使用事务，首选需要通过DB.Begin()创建一个事务的引用对象。记住，Exec以及其他查询动作每次都会向DB索要一个连接，并且最终会将连接放回连接池。由于无法保证你每次索要的连接与Begin()执行时所在的连接是同一个连接，所以，要使用事务，必须先调用DB.Begin().正确的使用方法如下：\ntx, err := db.Begin() err = tx.Exec(...) err = tx.Commit() DB引用也有扩展行为Beginx()和MustBegin(),他们返回sqlx.Tx而不是sql.Tx。sqlx.Tx拥有sqlx.DB的所有扩展行为。 一旦事务是连接状态，Tx对象必须绑定并限定为单个从池中获取的连接，Tx在其整个生命周期中都将维持单个连接，只有调用Commit()或Rollback()才会释放连接。需要注意的是你应该至少调用这两个方法中的一个，否则，连接将会一直保持直到被GC回收。 由于在事务中只有一个连接可以被使用，所以一次只能执行一条语句。在执行其他查询之前，必须分别扫描完或关闭Row 和 Rows。在数据库服务器向你发送结果的时候，如果你尝试向数据库发送数据，这很可能会破坏当前连接。 Tx对象实际并不意味着在服务器上的任何行为，它只是执行了begin语句并绑定了单个连接。事务的实际行为，诸如：锁定和隔离等，在此不做具体说明，这些依赖于数据库。\nPrepared Statement （预处理语句） 在大多数数据库中，每当查询被执行时，语句会在后台被预处理。然而，你可以使用sqlx.DB.Prepare()显式的预处理语句，以便在其他地方可以重复使用。\nstmt, err := db.Prepare(`SELECT * FROM place WHERE telcode=?`) row = stmt.QueryRow(65) tx, err := db.Begin() txStmt, err := tx.Prepare(`SELECT * FROM place WHERE telcode=?`) row = txStmt.QueryRow(852) Prepare实际会在数据库执行预处理操作，所以，它需要占用一个链接。database/sql会抽象这一点：通过自动在新的链接上执行预处理操作，允许你使用同一个Stmt对象同时在多个连接上执行语句。Preparex()返回一个sqlx.Stmt对象，它拥有sqlx.DB和sqlx.Tx两个扩展的所有行为。\nstmt, err := db.Preparex(`SELECT * FROM place WHERE telcode=?`) var p Place err = stmt.Get(\u0026p, 852) 标准的sql.Tx对象也有一个Stmt()方法，它从一个已存在的Stmt对象中返回一个用于事务的特定Stmt对象。sqlx.Tx也有一个Stmtx的版本，它从一个已存在的sql.Stmt或sqlx.Stmt对象中创建一个用于事务的特定sqlx.Stmt对象。 关于Stmt对象，可参考pkg.go.dev中database/sql文档中的阶段概述：\nStmt is a prepared statement. A Stmt is safe for concurrent use by multiple goroutines. If a Stmt is prepared on a Tx or Conn, it will be bound to a single underlying connection forever. If the Tx or Conn closes, the Stmt will become unusable and all operations will return an error. If a Stmt is prepared on a DB, it will remain usable for the lifetime of the DB. When the Stmt needs to execute on a new underlying connection, it will prepare itself on the new connection automatically.\nQuery Helpers database/sql包不对查询语句文本做任何封装操作。这使得在sql代码中使用特定于后端的特性变得琐碎。你可以像在数据库中一样迅速的编写查询语句。虽然这很灵活，但是在编写某些类型的查询语句变得困难。\nIn Queries var levels = []int{4, 6, 7} query, args, err := sqlx.In(\"SELECT * FROM users WHERE level IN (?);\", levels) // sqlx.In returns queries with the `?` bindvar, we can rebind it for our backend query = db.Rebind(query) rows, err := db.Query(query, args...) db.Rebind可以用来获取适用于你的数据库驱动的query格式。例如：MySQL使用?作为占位符，而SQLite则可以使用?和$1作为占位符。具体参考bindvars章节\nNamed Queries 命名查询，通过映射到结构体字段名或者map的key来绑定变量到查询。不必映射所有字段。他包含两个与命名查询相关的查询动作：\nNamedQuery(…) (*sqlx.Rows, error) - like Queryx, but with named bindvars NamedExec(…) (sql.Result, error) - like Exec, but with named bindvars 和一个额外引用类型查询动作： NamedStmt - an sqlx.Stmt which can be prepared with named bindvars 使用示例：\n// named query with a struct p := Place{Country: \"South Africa\"} rows, err := db.NamedQuery(`SELECT * FROM place WHERE country=:country`, p) // named query with a map m := map[string]interface{}{\"city\": \"Johannesburg\"} result, err := db.NamedExec(`SELECT * FROM place WHERE city=:city`, m) 查询所有结果集：\np := Place{TelephoneCode: 50} pp := []Place{} // select all telcodes \u003e 50 nstmt, err := db.PrepareNamed(`SELECT * FROM place WHERE telcode \u003e :telcode`) err = nstmt.Select(\u0026pp, p) 命名查询通过解析:param语法并将其替换为底层数据库支持的占位符，然后在执行的时候映射查询条件。所以它适用于所有sqlx支持的数据库。你也可以使用sqlx.Named，他使用?占位符，并且可以和sqlx.In组合使用。\narg := map[string]interface{}{ \"published\": true, \"authors\": []{8, 19, 32, 44}, } query, args, err := sqlx.Named(\"SELECT * FROM articles WHERE published=:published AND author_id IN (:authors)\", arg) query, args, err := sqlx.In(query, args...) query = db.Rebind(query) db.Query(query, args...) Advanced Scanning StructScan看似复杂。他支持结构体嵌套，并且使用与Go的属性嵌套及方法访问相同的优先级规则分配字段。一个常见的用法是在多个表之间共享表模型的公共部分。\ntype AutoIncr struct { ID uint64 Created time.Time } type Place struct { Address string AutoIncr } type Person struct { Name string AutoIncr } 上面的代码中：Person和Place将都可以从StructScan接收id和created列的值，因为他们都嵌套了AutoIncr结构体。这个特性可以让你快速的为链表查询创建临时表。他可以递归的工作。下面的Employee结构体拥有Person的Name字段以及AutoIncr的 ID和Created字段的访问权限。\ntype Employee struct { BossID uint64 EmployeeID uint64 Person } 注意：sqlx历史版本为非嵌入式结构体支持此特性，这使得开发者感到困惑。因为有用户利用此特性定义关系并嵌入相同的结构体两次：\ntype Child struct { Father Person Mother Person } 这会引起一些问题。在Go中隐藏派生字段是合法的.如果上面的Employee定义了Name字段，他的优先级将会高于Person结构体的Name字段。但是模糊的选择器是非法的且会引起运行时错误。如果我们想要为Person和Place快速的创建链表查询，我们应该将id定义到哪里？是他们两个结构体都嵌入的AutoIncr结构体中？这是否会有错误？ 由于sqlx构建字段名到字段地址的映射方式，当你扫描数据到结构体时，它并不知道在遍历结构体树的过程中是否遇到了同一个字段名两次。所以，与Go不同，StructScan将会选择首次遇到的这个字段。由于Go结构体字段是从上到下排序，并且sqlx使用广度优先原则便利以维持优先级原则，因此StructScan使用最浅层（多层嵌套情况下），且最前面的定义的字段。 例如：在以下结构体中，StructScan会将id列的值赋给Persion.AutoIncr.ID,也可以通过Persion.ID来访问。为了避免混淆，建议在你的SQL种使用AS关键字为列设置别名。\ntype PersonPlace struct { Person Place } Scan Destination Safety 通常情况下，如果列的值不能映射到目标数据结构的字段上，StructScan会返回一个错误。这模仿了Go中对未使用变量的处理方式，但是与标准库编码解码包例如：encoding/json不同。因为SQL通常以比解析JSON更可控的方式执行，这些错误通常是编码错误，默认情况下会返回错误。 像未使用的变量一样，你忽略的列是对网络和数据库资源的浪费，并且，在没有映射器告诉你一些东西未找到的情况下，尽早的检测出不兼容的映射和结构体标签中的错别字是非常困难的。 尽管如此，在某些情况下需要忽略没有目标结构的列。为此，每一种引用类型都实现了一个Unsafe方法，它返回这个引用的拷贝，这份拷贝关闭了安全功能。 Unsafe()方法说明：\n// Unsafe returns a version of DB which will silently succeed to scan when // columns in the SQL result have no fields in the destination struct. // sqlx.Stmt and sqlx.Tx which are created from this DB will inherit its // safety behavior. func (db *DB) Unsafe() *DB { return \u0026DB{DB: db.DB, driverName: db.driverName, unsafe: true, Mapper: db.Mapper} } Usage：\nvar p Person // err here is not nil because there are no field destinations for columns in `place` err = db.Get(\u0026p, \"SELECT * FROM person, place LIMIT 1;\") // this will NOT return an error, even though place columns have no destination udb := db.Unsafe() err = udb.Get(\u0026p, \"SELECT * FROM person, place LIMIT 1;\") Controlling Name Mappint 用作StructScan目标的结构体字段必须大写才能被sqlx访问。因此，sqlx使用NameMapper将strings.ToLower应用到字段名以映射他们到查询的结果的列。这并不总是可取的，依赖于数据库对象，所以sqlx允许通过多种方式自定义映射。 最简单的一种方式就是通过sqlx.DB.MapperFunc为引用类型设置映射，改方法接受一个func(string)string类型的参数。如果你的库需要特定的映射器，并且你不想污染sqlx.DB，你可以创建一个DB拷贝用于特定映射场景。\n// if our db schema uses ALLCAPS columns, we can use normal fields db.MapperFunc(strings.ToUpper) // suppose a library uses lowercase columns, we can create a copy copy := sqlx.NewDb(db.DB, db.DriverName()) copy.MapperFunc(strings.ToLower) sqlx.DB使用 sqlx/reflectx包的 Mapper 来实现底层的映射逻辑，并且通过 sqlx.DB.Mapper导出当前活跃的映射器。你可以通过直接设置来自定义数据库上的映射器：\nimport \"github.com/jmoiron/sqlx/reflectx\" // Create a new mapper which will use the struct field tag \"json\" instead of \"db\" db.Mapper = reflectx.NewMapperFunc(\"json\", strings.ToLower) Alternate Scan Types 除了使用 StructScan 和 Scan ,sqlx的查询行结果也可以返回切片或 map集合：\nrows, err := db.Queryx(\"SELECT * FROM place\") for rows.Next() { // cols is an []interface{} of all of the column results cols, err := rows.SliceScan() } rows, err := db.Queryx(\"SELECT * FROM place\") for rows.Next() { results := make(map[string]interface{}) err = rows.MapScan(results) } SliceScan一般使用在你不知道会返回哪些字段的情况下。MapScan与之相同，但 MapScan将列映射到 interface{}类型值上。这里需要重点注意的是， rows.Columns()返回的结果不包含完整的名称。例如：\nSELECT a.id, b.id FROM a NATURAL JOIN b 将会导致一个 []string{\"id\",\"id\"}格式的列结果，这破坏了你的map中的一个结果。\nCustom Types 上面的列子都使用了内置类型来扫描或者查询，但是 database/sql 提供了接口允许你使用自定义的类型：\nsql.Scanner allows you to use custom types in a Scan() driver.Valuer allows you to use custom types in a Query/QueryRow/Exec 这些是标准的接口，使用他们可以确保在 database/sql 上提供的服务可以移植到任何库。具体如何使用请参考 Built In Interfaces 这篇文章，或者查看 sqlx/types 包，改包实现了一些标准的实用类型。 The Connection Pool 准备语句和查询的执行都需要连接，DB对象会管理一个连接池，以保证它可以进行安全的并发查询。有两种方法可以控制连接池的大小：\nDB.SetMaxIdleConns(n int) DB.SetMaxOpenConns(n int) 默认情况下，池子可以无限增长，并且只要池中没有可用连接，就会创建一个连接。你可以使用 DB.SetMaxOpenConns设置最大连接数。未使用的连接会被标记为空闲，如果他们不被需要将会被关闭。为避免建立和关闭大量连接，使用 DB.SetMaxIdleConns 将最大空闲连接数设置为适合你查询负载的大小是一种明智的选择。 很容易陷入阻塞连接的困境中，为了防止这种情况： 确保 Scan() 每个row对象 确保通过 Next()对每个Rows对象进行完整迭代或调用Close() 确保每一个事务都通过 Commit() 或 Rollback() 返回连接 如果你忘记这些操作，连接将会一直阻塞直到被 GC 回收，并且你的数据库会立刻停止建立更多的连接，以此抵消当前正在使用的这个链接。注意 Rows.Close() 可以被多次安全的调用，所以不用担心在不需要的地方调用它。\n","wordCount":"6453","inLanguage":"en","datePublished":"2022-08-04T14:50:30+08:00","dateModified":"2022-08-04T14:50:30+08:00","author":{"@type":"Person","name":"Axlrose"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://echotrue.github.io/blog/golang/sqlx/"},"publisher":{"@type":"Organization","name":"AXLROSE","logo":{"@type":"ImageObject","url":"https://echotrue.github.io/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css><link rel=stylesheet href=/css/main.min.b18e8501c4f9c51c7bc74c831f88a4705978246e383d68ba514a05459901ef6f.css integrity="sha256-sY6FAcT5xRx7x0yDH4ikcFl4JG44PWi6UUoFRZkB728=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/prism.min.ab059a12f053f9764c2b65f5e83ea3a2e77c9957e453e01e0478a8ab6b11109f.css><script src=/js/prism.min.4efeed559740892c1071317ffd1e799722e52463c486cfb182fdef01622950fc.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/blog>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/series>Series</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/book>Book</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Sqlx</h1></header><p><small>August 4, 2022&nbsp;· 6453 words&nbsp;· 13 min</small>
<small>·
<a href=https://echotrue.github.io/tags/go/>Go</a>
<a href=https://echotrue.github.io/tags/sqlx/>Sqlx</a></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><ul><li><a href=#handle-types-引用类型>Handle Types (引用类型)</a></li><li><a href=#querying-101-查询概述>Querying 101 (查询概述)</a></li><li><a href=#transactions-事务>Transactions (事务)</a></li><li><a href=#prepared-statement-预处理语句>Prepared Statement （预处理语句）</a></li><li><a href=#query-helpers>Query Helpers</a></li><li><a href=#advanced-scanning>Advanced Scanning</a></li><li><a href=#custom-types>Custom Types</a></li><li><a href=#the-connection-pool>The Connection Pool</a></li></ul></li></ul></nav></div><section class=blog-content><h3 id=handle-types-引用类型>Handle Types (引用类型)</h3><p><code>sqlx</code>旨在和<code>database/sql</code>具有相同的感觉，他有四种引用类型</p><ul><li><code>sqlx.DB</code> 类似于<code>sql.DB</code>,是数据库的表示</li><li><code>sqlx.Tx</code>类似于<code>sql.Tx</code>,是事务的表示</li><li><code>sqlx.Stmt</code>类似于<code>sql.Stmt</code>,是预处理语句的表示</li><li><code>sqlx.NamedStmt</code>是一种支持命名参数的预处理语句的表示</li></ul><p>引用类型都嵌入了他们在<code>database/sql</code>中的等效物，这就意味着当你调用<code>sqlx.DB.Query()</code>，实际是调用与<code>sql.DB.Query</code>相同的代码。</p><p>除此之外，还有两种光标类型：</p><h3 id=querying-101-查询概述>Querying 101 (查询概述)</h3><p>引用类型实现了以下相同的操作来查询数据库</p><ul><li><code>Exec(...) (sql.Result, error)</code> - unchanged from database/sql</li><li><code>Query(...) (*sql.Rows, error)</code> - unchanged from database/sql</li><li><code>QueryRow(...) *sql.Row</code> - unchanged from database/sql</li></ul><p>以下这些是内置操作的扩展</p><ul><li><code>MustExec() sql.Result</code> &ndash; Exec, but panic on error</li><li><code>Queryx(...) (*sqlx.Rows, error)</code> - Query, but return an sqlx.Rows</li><li><code>QueryRowx(...) *sqlx.Row</code> &ndash; QueryRow, but return an sqlx.Row</li></ul><p>还有这些新的语义：</p><ul><li><code>Get(dest interface{}, ...) error</code></li><li><code>Select(dest interface{}, ...) error</code></li></ul><h4 id=exec-and-mustexec>Exec and MustExec</h4><p>这两个方法都是用于执行插入，修改以及DDL语句。区别是他们的错误处理机制不一样，<code>Exec</code>会将结果和错误返回，由开发者自行处理。而<code>MustExec</code>遇到错误会抛出恐慌<code>panic</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// Create table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>schema</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>`CREATE TABLE place (country text,city text NULL,telcode integer);`</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>result</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Exec</span>(<span style=color:#a6e22e>schema</span>)  
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalln</span>(<span style=color:#a6e22e>err</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Insert
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>schema</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>`INSERT INTO place (country,telcode) VALUES (?,?)`</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>MustExec</span>(<span style=color:#a6e22e>schema</span>, <span style=color:#e6db74>&#34;Hong Kong&#34;</span>, <span style=color:#ae81ff>852</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//result.LastInsertId()  
</span></span></span><span style=display:flex><span><span style=color:#75715e>//result.RowsAffected()
</span></span></span></code></pre></div><h4 id=query>Query</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// fetch all places from the db
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rows</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Query</span>(<span style=color:#e6db74>&#34;SELECT country, city, telcode FROM place&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// iterate over each row
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>rows</span>.<span style=color:#a6e22e>Next</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>country</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// note that city can be NULL, so we use the NullString type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>city</span> <span style=color:#a6e22e>sql</span>.<span style=color:#a6e22e>NullString</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>telcode</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>rows</span>.<span style=color:#a6e22e>Scan</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>country</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>city</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>telcode</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// check the error from rows
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>rows</span>.<span style=color:#a6e22e>Err</span>()
</span></span></code></pre></div><p>应该像数据库游标一样看待<code>Rows</code>，而不是将其看作一个具体的结果集。尽管数据库驱动缓冲行为有所不同，但是通过<code>Next()</code>迭代能够有效的约束大型查询结果集的内存使用，因为一次只扫描一行。<code>Scan()</code>通过反射来将数据库列的类型映射到<code>Go</code>的类型，例如：string,[]byte等等。如果不迭代所有行的结果，请确保调用<code>rows.Close()</code>以便将连接返回到连接池。
<code>Query</code>查询返回的<code>error</code>是数据库服务<code>preparing</code>或<code>executing</code>过程中发生的任意错误。这些错误包含从连接池中获取无效的连接，尽管<code>database/sql</code>会重试10次来尝试找到或创建正常的连接。通常，这些错误是由SQL语法错误，类型错误，字段名和表明错误引起。
大多数情况下，<code>Rows.Scan</code>会复制其从数据库驱动中获取的数据，因为它不知道数据库驱动将会如何重复使用缓冲区。特殊类型<code>sql.RawBytes</code>可以用来从数据库驱动返回的实际数据中获取一个零拷贝的字节切片。下次调用<code>Next()</code>之后，这个值将不再有效，因为这个值所在的内存可能已经被覆盖。
<code>Query</code>查询使用的连接会一直保持活跃状态，直到通过<code>Next()</code>迭代完查询出的所有行，或者<code>rows.Close()</code>被调用。此时，连接才会被释放。
<code>Queryx</code>和<code>Query</code>用法基本一样，只是他返回一个<code>sqlx.Rows</code>对象，这个对象拥有更加丰富的<code>scan</code>行为可供选择。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Place</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Country</span>       <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>City</span>          <span style=color:#a6e22e>sql</span>.<span style=color:#a6e22e>NullString</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>TelephoneCode</span> <span style=color:#66d9ef>int</span> <span style=color:#e6db74>`db:&#34;telcode&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>rows</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Queryx</span>(<span style=color:#e6db74>&#34;SELECT * FROM place&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>rows</span>.<span style=color:#a6e22e>Next</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#a6e22e>Place</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>rows</span>.<span style=color:#a6e22e>StructScan</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>StructScan()</code>是<code>sql.Rows</code>主要的扩展行为，他会扫描查询结果并映射到结构体字段中。注意，这些字段必须是导出的（首字母大写），以便<code>sqlx</code>能够将数据写入，这个规则适用于Go中的所有类型（json,xml）的<code>Marshalling</code>(编码)和<code>UNMarshalling</code>(解码)。可以使用结构体标签<code>db</code>指定数据表列名和结构体字段的映射关系，或者使用<code>db.MapperFunc()</code>设置新的默认映射关系。默认是使用<code>strings.Lower</code>将结构体字段转小写来匹配数据表列名。</p><h4 id=queryrow>QueryRow</h4><p><code>QueryRow</code>从数据表提取一条记录。它从连接池中获取一个连接，然后通过<code>Query</code>执行查询，返回一个内部包含<code>Rows</code>对象的<code>Row</code>对象。
与<code>Query</code>不同，<code>QueryRow</code>返回没有错误的<code>Row</code>类型结果，使得对查询结果的链式<code>Scan</code>操作是安全的。如果执行查询过程中发生错误，错误会通过<code>Scan</code>返回。如果没有查询到结果，<code>Scan</code>返回<code>sql.ErrNoRows</code>错误。如果<code>Scan</code>本身发生错误（例如：类型不匹配）,错误同样会被返回。
查询结果<code>Row</code>内部的<code>Rows</code>结构体在<code>Scan</code>执行完后会关闭，这就意味着，<code>QueryRow</code>查询所在的数据库连接一直会保持到查询结果被扫描完。同样意味着<code>sql.RawBytes</code>在这里也不可用，由于被引用的内存块属于数据库驱动，并且调用返回时该内存块可能已经无效。
<code>sqlx</code>扩展的方法<code>QueryRowx</code>会返回<code>sqlx.Row</code>代替<code>sql.Row</code>，它实现了上述介绍以及高阶扫描中<code>Rows</code>相同的扫描扩展。</p><h4 id=get-and-select>Get and Select</h4><p><code>Get</code>和<code>Select</code>是引用类型的节省时间的扩展，它将查询的执行和灵活的扫描语义相结合。为了清楚的解释它们，我们不得不谈论下什么是<code>scannable</code>(可扫描的)：</p><ul><li>不是结构体类型的值是可扫描的，例如：<code>string</code>, <code>int</code></li><li>实现了<code>sql.Scanner</code>接口的值是可扫描的</li><li>没有导出字段的结构体可以是扫描的(eg. <code>time.Time</code>)
<code>Get</code>和<code>Select</code>使用<code>rows.Scan</code>在可扫描类型上，使用<code>rows.StructScan</code>在不可扫描类型上。它们与<code>QueryRow</code>和<code>Query</code>大致相似，<code>Get</code>主要用来获取单条记录并扫描它，<code>Select</code>主要用来获取一个结果集。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Place</span>{}
</span></span><span style=display:flex><span><span style=color:#a6e22e>pp</span> <span style=color:#f92672>:=</span> []<span style=color:#a6e22e>Place</span>{}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>// this will pull the first place directly into p
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>, <span style=color:#e6db74>&#34;SELECT * FROM place LIMIT 1&#34;</span>)
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>// this will pull places with telcode &gt; 50 into the slice pp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Select</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>, <span style=color:#e6db74>&#34;SELECT * FROM place WHERE telcode &gt; ?&#34;</span>, <span style=color:#ae81ff>50</span>)
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>// they work with regular types as well
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>id</span>, <span style=color:#e6db74>&#34;SELECT count(*) FROM place&#34;</span>)
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>// fetch at most 10 place names
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>names</span> []<span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Select</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>names</span>, <span style=color:#e6db74>&#34;SELECT name FROM place LIMIT 10&#34;</span>)
</span></span></code></pre></div><p><code>Get</code>和<code>Select</code>都将会关闭它们在查询执行过程中创建的<code>Rows</code>对象，并且返回在这个过程中发生的任何错误。由于它们在内部使用<code>StructScan</code>,因此"高级扫描"中介绍的部分也适用于这两个方法。
<code>Select</code>可以为你节省很多输入，但是，请谨记！它在语义上和<code>Queryx</code>不同，因为它会将整个查询结果集一次性的加载进内存，如果这个结果集没有被查询限制到一个合理的大小，使用经典的<code>Queryx/StructScan</code>迭代反而是更好的选择。</p><h3 id=transactions-事务>Transactions (事务)</h3><p>要使用事务，首选需要通过<code>DB.Begin()</code>创建一个事务的引用对象。记住，<code>Exec</code>以及其他查询动作每次都会向<code>DB</code>索要一个连接，并且最终会将连接放回连接池。由于无法保证你每次索要的连接与<code>Begin()</code>执行时所在的连接是同一个连接，所以，要使用事务，必须先调用<code>DB.Begin()</code>.正确的使用方法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>tx</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Begin</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Exec</span>(<span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Commit</span>()
</span></span></code></pre></div><p><code>DB</code>引用也有扩展行为<code>Beginx()</code>和<code>MustBegin()</code>,他们返回<code>sqlx.Tx</code>而不是<code>sql.Tx</code>。<code>sqlx.Tx</code>拥有<code>sqlx.DB</code>的所有扩展行为。
一旦事务是连接状态，<code>Tx</code>对象必须绑定并限定为单个从池中获取的连接，<code>Tx</code>在其整个生命周期中都将维持单个连接，只有调用<code>Commit()</code>或<code>Rollback()</code>才会释放连接。需要注意的是你应该至少调用这两个方法中的一个，否则，连接将会一直保持直到被GC回收。
由于在事务中只有一个连接可以被使用，所以一次只能执行一条语句。在执行其他查询之前，必须分别扫描完或关闭<code>Row</code> 和 <code>Rows</code>。在数据库服务器向你发送结果的时候，如果你尝试向数据库发送数据，这很可能会破坏当前连接。
<code>Tx</code>对象实际并不意味着在服务器上的任何行为，它只是执行了<code>begin</code>语句并绑定了单个连接。事务的实际行为，诸如：锁定和隔离等，在此不做具体说明，这些依赖于数据库。</p><h3 id=prepared-statement-预处理语句>Prepared Statement （预处理语句）</h3><p>在大多数数据库中，每当查询被执行时，语句会在后台被预处理。然而，你可以使用<code>sqlx.DB.Prepare()</code>显式的预处理语句，以便在其他地方可以重复使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>stmt</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Prepare</span>(<span style=color:#e6db74>`SELECT * FROM place WHERE telcode=?`</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>row</span> = <span style=color:#a6e22e>stmt</span>.<span style=color:#a6e22e>QueryRow</span>(<span style=color:#ae81ff>65</span>)
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>tx</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Begin</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>txStmt</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Prepare</span>(<span style=color:#e6db74>`SELECT * FROM place WHERE telcode=?`</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>row</span> = <span style=color:#a6e22e>txStmt</span>.<span style=color:#a6e22e>QueryRow</span>(<span style=color:#ae81ff>852</span>)
</span></span></code></pre></div><p><code>Prepare</code>实际会在数据库执行预处理操作，所以，它需要占用一个链接。<code>database/sql</code>会抽象这一点：通过自动在新的链接上执行预处理操作，允许你使用同一个<code>Stmt</code>对象同时在多个连接上执行语句。<code>Preparex()</code>返回一个<code>sqlx.Stmt</code>对象，它拥有<code>sqlx.DB</code>和<code>sqlx.Tx</code>两个扩展的所有行为。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>stmt</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Preparex</span>(<span style=color:#e6db74>`SELECT * FROM place WHERE telcode=?`</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#a6e22e>Place</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>stmt</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>, <span style=color:#ae81ff>852</span>)
</span></span></code></pre></div><p>标准的<code>sql.Tx</code>对象也有一个<code>Stmt()</code>方法，它从一个已存在的<code>Stmt</code>对象中返回一个用于事务的特定<code>Stmt</code>对象。<code>sqlx.Tx</code>也有一个<code>Stmtx</code>的版本，它从一个已存在的<code>sql.Stmt</code>或<code>sqlx.Stmt</code>对象中创建一个用于事务的特定<code>sqlx.Stmt</code>对象。
关于<code>Stmt</code>对象，可参考<code>pkg.go.dev</code>中<code>database/sql</code>文档中的阶段概述：</p><blockquote><p>Stmt is a prepared statement. A Stmt is safe for concurrent use by multiple goroutines.
If a Stmt is prepared on a Tx or Conn, it will be bound to a single underlying connection forever. If the Tx or Conn closes, the Stmt will become unusable and all operations will return an error. If a Stmt is prepared on a DB, it will remain usable for the lifetime of the DB. When the Stmt needs to execute on a new underlying connection, it will prepare itself on the new connection automatically.</p></blockquote><h3 id=query-helpers>Query Helpers</h3><p><code>database/sql</code>包不对查询语句文本做任何封装操作。这使得在<code>sql</code>代码中使用特定于后端的特性变得琐碎。你可以像在数据库中一样迅速的编写查询语句。虽然这很灵活，但是在编写某些类型的查询语句变得困难。</p><h4 id=in-queries>In Queries</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>levels</span> = []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>query</span>, <span style=color:#a6e22e>args</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sqlx</span>.<span style=color:#a6e22e>In</span>(<span style=color:#e6db74>&#34;SELECT * FROM users WHERE level IN (?);&#34;</span>, <span style=color:#a6e22e>levels</span>)
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>// sqlx.In returns queries with the `?` bindvar, we can rebind it for our backend
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>query</span> = <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Rebind</span>(<span style=color:#a6e22e>query</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>rows</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Query</span>(<span style=color:#a6e22e>query</span>, <span style=color:#a6e22e>args</span><span style=color:#f92672>...</span>)
</span></span></code></pre></div><p><code>db.Rebind</code>可以用来获取适用于你的数据库驱动的<code>query</code>格式。例如：MySQL使用<code>?</code>作为占位符，而SQLite则可以使用<code>?</code>和<code>$1</code>作为占位符。具体参考<code>bindvars</code>章节</p><h4 id=named-queries>Named Queries</h4><p>命名查询，通过映射到结构体字段名或者<code>map</code>的<code>key</code>来绑定变量到查询。不必映射所有字段。他包含两个与命名查询相关的查询动作：</p><ul><li>NamedQuery(&mldr;) (*sqlx.Rows, error) - like Queryx, but with named bindvars</li><li>NamedExec(&mldr;) (sql.Result, error) - like Exec, but with named bindvars
和一个额外引用类型查询动作：</li><li>NamedStmt - an sqlx.Stmt which can be prepared with named bindvars</li></ul><p>使用示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// named query with a struct
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Place</span>{<span style=color:#a6e22e>Country</span>: <span style=color:#e6db74>&#34;South Africa&#34;</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>rows</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>NamedQuery</span>(<span style=color:#e6db74>`SELECT * FROM place WHERE country=:country`</span>, <span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>// named query with a map
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>interface</span>{}{<span style=color:#e6db74>&#34;city&#34;</span>: <span style=color:#e6db74>&#34;Johannesburg&#34;</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>result</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>NamedExec</span>(<span style=color:#e6db74>`SELECT * FROM place WHERE city=:city`</span>, <span style=color:#a6e22e>m</span>)
</span></span></code></pre></div><p>查询所有结果集：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Place</span>{<span style=color:#a6e22e>TelephoneCode</span>: <span style=color:#ae81ff>50</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>pp</span> <span style=color:#f92672>:=</span> []<span style=color:#a6e22e>Place</span>{}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>// select all telcodes &gt; 50
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>nstmt</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>PrepareNamed</span>(<span style=color:#e6db74>`SELECT * FROM place WHERE telcode &gt; :telcode`</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>nstmt</span>.<span style=color:#a6e22e>Select</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>, <span style=color:#a6e22e>p</span>)
</span></span></code></pre></div><p>命名查询通过解析<code>:param</code>语法并将其替换为底层数据库支持的占位符，然后在执行的时候映射查询条件。所以它适用于所有<code>sqlx</code>支持的数据库。你也可以使用<code>sqlx.Named</code>，他使用<code>?</code>占位符，并且可以和<code>sqlx.In</code>组合使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>arg</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>interface</span>{}{
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;published&#34;</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;authors&#34;</span>: []{<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>19</span>, <span style=color:#ae81ff>32</span>, <span style=color:#ae81ff>44</span>},
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>query</span>, <span style=color:#a6e22e>args</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sqlx</span>.<span style=color:#a6e22e>Named</span>(<span style=color:#e6db74>&#34;SELECT * FROM articles WHERE published=:published AND author_id IN (:authors)&#34;</span>, <span style=color:#a6e22e>arg</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>query</span>, <span style=color:#a6e22e>args</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sqlx</span>.<span style=color:#a6e22e>In</span>(<span style=color:#a6e22e>query</span>, <span style=color:#a6e22e>args</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>query</span> = <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Rebind</span>(<span style=color:#a6e22e>query</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Query</span>(<span style=color:#a6e22e>query</span>, <span style=color:#a6e22e>args</span><span style=color:#f92672>...</span>)
</span></span></code></pre></div><h3 id=advanced-scanning>Advanced Scanning</h3><p><code>StructScan</code>看似复杂。他支持结构体嵌套，并且使用与<code>Go</code>的属性嵌套及方法访问相同的优先级规则分配字段。一个常见的用法是在多个表之间共享表模型的公共部分。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>AutoIncr</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ID</span>       <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Created</span>  <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Place</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Address</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>AutoIncr</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Person</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>AutoIncr</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码中：<code>Person</code>和<code>Place</code>将都可以从<code>StructScan</code>接收<code>id</code>和<code>created</code>列的值，因为他们都嵌套了<code>AutoIncr</code>结构体。这个特性可以让你快速的为链表查询创建临时表。他可以递归的工作。下面的<code>Employee</code>结构体拥有<code>Person</code>的<code>Name</code>字段以及<code>AutoIncr</code>的 <code>ID</code>和<code>Created</code>字段的访问权限。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Employee</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>BossID</span> <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>EmployeeID</span> <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意：<code>sqlx</code>历史版本为非嵌入式结构体支持此特性，这使得开发者感到困惑。因为有用户利用此特性定义关系并嵌入相同的结构体两次：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Child</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Father</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Mother</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这会引起一些问题。在Go中隐藏派生字段是合法的.如果上面的<code>Employee</code>定义了<code>Name</code>字段，他的优先级将会高于<code>Person</code>结构体的<code>Name</code>字段。但是模糊的选择器是非法的且会引起运行时错误。如果我们想要为<code>Person</code>和<code>Place</code>快速的创建链表查询，我们应该将<code>id</code>定义到哪里？是他们两个结构体都嵌入的<code>AutoIncr</code>结构体中？这是否会有错误？
由于<code>sqlx</code>构建字段名到字段地址的映射方式，当你扫描数据到结构体时，它并不知道在遍历结构体树的过程中是否遇到了同一个字段名两次。所以，与Go不同，<code>StructScan</code>将会选择首次遇到的这个字段。由于Go结构体字段是从上到下排序，并且<code>sqlx</code>使用广度优先原则便利以维持优先级原则，因此<code>StructScan</code>使用最浅层（多层嵌套情况下），且最前面的定义的字段。
例如：在以下结构体中，<code>StructScan</code>会将<code>id</code>列的值赋给<code>Persion.AutoIncr.ID</code>,也可以通过<code>Persion.ID</code>来访问。为了避免混淆，建议在你的SQL种使用<code>AS</code>关键字为列设置别名。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>PersonPlace</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Place</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=scan-destination-safety>Scan Destination Safety</h4><p>通常情况下，如果列的值不能映射到目标数据结构的字段上，<code>StructScan</code>会返回一个错误。这模仿了Go中对未使用变量的处理方式，但是与标准库编码解码包例如：<code>encoding/json</code>不同。因为SQL通常以比解析<code>JSON</code>更可控的方式执行，这些错误通常是编码错误，默认情况下会返回错误。
像未使用的变量一样，你忽略的列是对网络和数据库资源的浪费，并且，在没有映射器告诉你一些东西未找到的情况下，尽早的检测出不兼容的映射和结构体标签中的错别字是非常困难的。
尽管如此，在某些情况下需要忽略没有目标结构的列。为此，每一种引用类型都实现了一个<code>Unsafe</code>方法，它返回这个引用的拷贝，这份拷贝关闭了安全功能。
Unsafe()方法说明：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// Unsafe returns a version of DB which will silently succeed to scan when
</span></span></span><span style=display:flex><span><span style=color:#75715e>// columns in the SQL result have no fields in the destination struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// sqlx.Stmt and sqlx.Tx which are created from this DB will inherit its
</span></span></span><span style=display:flex><span><span style=color:#75715e>// safety behavior.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>db</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DB</span>) <span style=color:#a6e22e>Unsafe</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>DB</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>DB</span>{<span style=color:#a6e22e>DB</span>: <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>DB</span>, <span style=color:#a6e22e>driverName</span>: <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>driverName</span>, <span style=color:#a6e22e>unsafe</span>: <span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>Mapper</span>: <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Mapper</span>}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Usage：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// err here is not nil because there are no field destinations for columns in `place`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>, <span style=color:#e6db74>&#34;SELECT * FROM person, place LIMIT 1;&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// this will NOT return an error, even though place columns have no destination
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>udb</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Unsafe</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>udb</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>, <span style=color:#e6db74>&#34;SELECT * FROM person, place LIMIT 1;&#34;</span>)
</span></span></code></pre></div><h4 id=controlling-name-mappint>Controlling Name Mappint</h4><p>用作<code>StructScan</code>目标的结构体字段必须大写才能被<code>sqlx</code>访问。因此，<code>sqlx</code>使用<code>NameMapper</code>将<code>strings.ToLower</code>应用到字段名以映射他们到查询的结果的列。这并不总是可取的，依赖于数据库对象，所以<code>sqlx</code>允许通过多种方式自定义映射。
最简单的一种方式就是通过<code>sqlx.DB.MapperFunc</code>为引用类型设置映射，改方法接受一个<code>func(string)string</code>类型的参数。如果你的库需要特定的映射器，并且你不想污染<code>sqlx.DB</code>，你可以创建一个<code>DB</code>拷贝用于特定映射场景。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// if our db schema uses ALLCAPS columns, we can use normal fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>MapperFunc</span>(<span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>ToUpper</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// suppose a library uses lowercase columns, we can create a copy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>copy</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sqlx</span>.<span style=color:#a6e22e>NewDb</span>(<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>DB</span>, <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>DriverName</span>())
</span></span><span style=display:flex><span><span style=color:#a6e22e>copy</span>.<span style=color:#a6e22e>MapperFunc</span>(<span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>ToLower</span>)
</span></span></code></pre></div><p><code>sqlx.DB</code>使用 <code>sqlx/reflectx</code>包的 <code>Mapper</code> 来实现底层的映射逻辑，并且通过 <code>sqlx.DB.Mapper</code>导出当前活跃的映射器。你可以通过直接设置来自定义数据库上的映射器：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;github.com/jmoiron/sqlx/reflectx&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Create a new mapper which will use the struct field tag &#34;json&#34; instead of &#34;db&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Mapper</span> = <span style=color:#a6e22e>reflectx</span>.<span style=color:#a6e22e>NewMapperFunc</span>(<span style=color:#e6db74>&#34;json&#34;</span>, <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>ToLower</span>)
</span></span></code></pre></div><h4 id=alternate-scan-types>Alternate Scan Types</h4><p>除了使用 <code>StructScan</code> 和 <code>Scan</code> ,<code>sqlx</code>的查询行结果也可以返回切片或 <code>map</code>集合：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>rows</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Queryx</span>(<span style=color:#e6db74>&#34;SELECT * FROM place&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>rows</span>.<span style=color:#a6e22e>Next</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// cols is an []interface{} of all of the column results
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>cols</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rows</span>.<span style=color:#a6e22e>SliceScan</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rows</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Queryx</span>(<span style=color:#e6db74>&#34;SELECT * FROM place&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>rows</span>.<span style=color:#a6e22e>Next</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>results</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>interface</span>{})
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>rows</span>.<span style=color:#a6e22e>MapScan</span>(<span style=color:#a6e22e>results</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>SliceScan</code>一般使用在你不知道会返回哪些字段的情况下。<code>MapScan</code>与之相同，但 <code>MapScan</code>将列映射到 <code>interface{}</code>类型值上。这里需要重点注意的是， <code>rows.Columns()</code>返回的结果不包含完整的名称。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>SELECT</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>id</span> <span style=color:#a6e22e>FROM</span> <span style=color:#a6e22e>a</span> <span style=color:#a6e22e>NATURAL</span> <span style=color:#a6e22e>JOIN</span> <span style=color:#a6e22e>b</span>
</span></span></code></pre></div><p>将会导致一个 <code>[]string{"id","id"}</code>格式的列结果，这破坏了你的map中的一个结果。</p><h3 id=custom-types>Custom Types</h3><p>上面的列子都使用了内置类型来扫描或者查询，但是 <code>database/sql</code> 提供了接口允许你使用自定义的类型：</p><ul><li>sql.Scanner allows you to use custom types in a Scan()</li><li>driver.Valuer allows you to use custom types in a Query/QueryRow/Exec
这些是标准的接口，使用他们可以确保在 <code>database/sql</code> 上提供的服务可以移植到任何库。具体如何使用请参考 <a href=http://jmoiron.net/blog/built-in-interfaces>Built In Interfaces</a> 这篇文章，或者查看 <code>sqlx/types</code> 包，改包实现了一些标准的实用类型。</li></ul><h3 id=the-connection-pool>The Connection Pool</h3><p>准备语句和查询的执行都需要连接，<code>DB</code>对象会管理一个连接池，以保证它可以进行安全的并发查询。有两种方法可以控制连接池的大小：</p><ul><li>DB.SetMaxIdleConns(n int)</li><li>DB.SetMaxOpenConns(n int)
默认情况下，池子可以无限增长，并且只要池中没有可用连接，就会创建一个连接。你可以使用 <code>DB.SetMaxOpenConns</code>设置最大连接数。未使用的连接会被标记为空闲，如果他们不被需要将会被关闭。为避免建立和关闭大量连接，使用 <code>DB.SetMaxIdleConns</code> 将最大空闲连接数设置为适合你查询负载的大小是一种明智的选择。
很容易陷入阻塞连接的困境中，为了防止这种情况：</li><li>确保 <code>Scan()</code> 每个row对象</li><li>确保通过 <code>Next()</code>对每个Rows对象进行完整迭代或调用<code>Close()</code></li><li>确保每一个事务都通过 <code>Commit()</code> 或 <code>Rollback()</code> 返回连接</li></ul><p>如果你忘记这些操作，连接将会一直阻塞直到被 <code>GC</code> 回收，并且你的数据库会立刻停止建立更多的连接，以此抵消当前正在使用的这个链接。注意 <code>Rows.Close()</code> 可以被多次安全的调用，所以不用担心在不需要的地方调用它。</p></section><div class=paginator><a class=prev href=https://echotrue.github.io/blog/golang/type/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>Type Tips</span></a>
<a class=next href=https://echotrue.github.io/blog/golang/functional-programming-in-golang/><span>Functional Programming in Golang</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://echotrue.github.io/>AXLROSE</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
Theme by
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>